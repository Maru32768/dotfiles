FUNCTION  lsp#get_progress()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1273
Called 15 times
Total time:   0.000131
 Self time:   0.000091

count  total (s)   self (s)
   15   0.000121   0.000081     return lsp#internal#work_done_progress#get_progress()

FUNCTION  lsp#client#is_server_instantiated_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:326
Called 3 times
Total time:   0.000029
 Self time:   0.000021

count  total (s)   self (s)
    3   0.000028   0.000020     return s:is_server_instantiated_notification(a:notification)

FUNCTION  <SNR>177_send_highlight_request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:55
Called 1 time
Total time:   0.000361
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003     let l:capability = 'lsp#capabilities#has_document_highlight_provider(v:val)'
    1   0.000193   0.000022     let l:servers = filter(lsp#get_allowed_servers(), l:capability)
                            
    1              0.000003     if empty(l:servers)
                                    return lsp#callbag#empty()
    1              0.000000     endif
                            
    1   0.000158   0.000024     return lsp#request(l:servers[0], { 'method': 'textDocument/documentHighlight', 'params': {   'textDocument': lsp#get_text_document_identifier(),   'position': lsp#get_position(),  }, })

FUNCTION  <SNR>203_parse_args()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/pos.vim:124
Called 8 times
Total time:   0.000273
 Self time:   0.000156

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
    8              0.000017   if len(a:args) > 1
    4              0.000013     return s:parse_args([a:args])
    4              0.000021   elseif len(a:args) == 1
    4              0.000018     if type(a:args[0]) == type({})
                                  return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
    4              0.000003     else
    4              0.000008       if len(a:args[0]) == 2
                                    return a:args[0]
    4              0.000003       else
    4              0.000020         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:227
Called 19 times
Total time:   0.108705
 Self time:   0.002224

count  total (s)   self (s)
   19              0.000056   if !has_key(s:contexts, a:winnr)
                                return ''
   19              0.000014   endif
   19              0.000061   let context = s:contexts[a:winnr]
                            
   19              0.000060   if get(w:, 'airline_active', 1)
   15              0.000042     let m = mode(1)
                                " Refer :help mode() to see the list of modes
                                "   NB: 'let mode' here refers to the display colour _groups_,
                                "   not the literal mode's code (i.e., m). E.g., Select modes
                                "   v, S and ^V use 'visual' since they are of similar ilk.
                                "   Some modes do not get recognised for status line purposes:
                                "   no, nov, noV, no^V, !, cv, and ce.
                                "   Mode name displayed is handled in init.vim (g:airline_mode_map).
                                "
   15              0.000043     if m[0] ==# "i"
                                  let mode = ['insert']  " Insert modes + submodes (i, ic, ix)
   15              0.000031     elseif m[0] == "R"
                                  let mode = ['replace']  " Replace modes + submodes (R, Rc, Rv, Rx) (NB: case sensitive as 'r' is a mode)
   15              0.000100     elseif m[0] =~ '\v(v|V||s|S|)'
                                    let mode = ['visual']  " Visual and Select modes (v, V, ^V, s, S, ^S))
   15              0.000018     elseif m ==# "t"
                                  let mode = ['terminal']  " Terminal mode (only has one mode (t))
   15              0.000059     elseif m[0] =~ '\v(c|r|!)'
    4              0.000007       let mode = ['commandline']  " c, cv, ce, r, rm, r? (NB: cv and ce stay showing as mode entered from)
   11              0.000007     else
   11              0.000021       let mode = ['normal']  " Normal mode + submodes (n, niI, niR, niV; plus operator pendings no, nov, noV, no^V)
   15              0.000008     endif
   15              0.000073     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   15              0.000011     endif
                                " Adjust to handle additional modes, which don't display correctly otherwise
   15              0.000086     if index(['niI', 'niR', 'niV', 'ic', 'ix', 'Rc', 'Rv', 'Rx', 'multi'], m) == -1
   15              0.000031       let m = m[0]
   15              0.000009     endif
   15              0.000062     let w:airline_current_mode = get(g:airline_mode_map, m, m)
    4              0.000003   else
    4              0.000010     let mode = ['inactive']
    4              0.000016     let w:airline_current_mode = get(g:airline_mode_map, '__')
   19              0.000013   endif
                            
   19              0.000056   if g:airline_detect_modified && &modified
    6              0.000015     call add(mode, 'modified')
   19              0.000012   endif
                            
   19              0.000025   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   19              0.000011   endif
                            
   19              0.000071   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   19              0.000005   endif
                            
   19              0.000028   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   19              0.000011   endif
                            
   19              0.000029   if &readonly || ! &modifiable
    4              0.000014     call add(mode, 'readonly')
   19              0.000008   endif
                            
   19              0.000061   let mode_string = join(mode)
   19              0.000066   if get(w:, 'airline_lastmode', '') != mode_string
    9   0.003468   0.000078     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    9   0.102520   0.000119     call airline#highlighter#highlight(mode, string(context.bufnr))
    9   0.000769   0.000079     call airline#util#doautocmd('AirlineModeChanged')
    9              0.000022     let w:airline_lastmode = mode_string
   19              0.000008   endif
                            
   19              0.000016   return ''

FUNCTION  <SNR>174_mapFSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:425
Called 11 times
Total time:   0.007798
 Self time:   0.000080

count  total (s)   self (s)
   11   0.004314   0.001601     call a:data['sink'](a:t, a:t == 1 ? a:data['f'](a:d) : a:d)

FUNCTION  <SNR>193_set_signs()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:113
Called 1 time
Total time:   0.000257
 Self time:   0.000121

count  total (s)   self (s)
                                " TODO: optimize by looking at params
    1              0.000003     if !g:lsp_diagnostics_signs_insert_mode_enabled
                                    if mode()[0] ==# 'i' | return | endif
    1              0.000000     endif
                            
    3              0.000010     for l:bufnr in range(1, bufnr('$'))
    2   0.000030   0.000019         if lsp#internal#diagnostics#state#_is_enabled_for_buffer(l:bufnr) && bufexists(l:bufnr) && bufloaded(l:bufnr)
    2   0.000075   0.000011             let l:uri = lsp#utils#get_buffer_uri(l:bufnr)
    3   0.000064   0.000045             for [l:server, l:diagnostics_response] in items(lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri))
    1   0.000050   0.000008                 call s:place_signs(l:server, l:diagnostics_response, l:bufnr)
    3              0.000002             endfor
    2              0.000000         endif
    3              0.000002     endfor

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:193
Called 15 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   15              0.000047   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   15              0.000057   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   15              0.000011   endif

FUNCTION  lsp#get_buffer_first_error_line()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1264
Called 15 times
Total time:   0.001682
 Self time:   0.000181

count  total (s)   self (s)
   15   0.001673   0.000172     return lsp#internal#diagnostics#first_line#get_first_error_line({'bufnr': bufnr('%')})

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:47
Called 4 times
Total time:   0.000080
 Self time:   0.000045

count  total (s)   self (s)
    4   0.000052   0.000017     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
    4              0.000002     endif
                            
    4              0.000004     return '/'

FUNCTION  <SNR>173_ensure_init()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:645
Called 1 time
Total time:   0.001106
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     let l:server = s:servers[a:server_name]
                            
    1              0.000002     if has_key(l:server, 'init_result')
    1   0.000013   0.000007         let l:msg = s:new_rpc_success('lsp server already initialized', { 'server_name': a:server_name, 'init_result': l:server['init_result'] })
    1   0.000009   0.000003         call lsp#log(l:msg)
    1   0.001077   0.000002         call a:cb(l:msg)
    1              0.000000         return
                                endif
                            
                                if has_key(l:server, 'init_callbacks')
                                    " waiting for initialize response
                                    call add(l:server['init_callbacks'], a:cb)
                                    let l:msg = s:new_rpc_success('waiting for lsp server to initialize', { 'server_name': a:server_name })
                                    call lsp#log(l:msg)
                                    return
                                endif
                            
                                " server has already started, but not initialized
                            
                                let l:server_info = l:server['server_info']
                                let l:root_uri = has_key(l:server_info, 'root_uri') ?  l:server_info['root_uri'](l:server_info) : ''
                                if empty(l:root_uri)
                                    let l:msg = s:new_rpc_error('ignore initialization lsp server due to empty root_uri', { 'server_name': a:server_name, 'lsp_id': l:server['lsp_id'] })
                                    call lsp#log(l:msg)
                                    let l:root_uri = lsp#utils#get_default_root_uri()
                                endif
                                let l:server['server_info']['_root_uri_resolved'] = l:root_uri
                                let l:server['workspace_folders'][l:root_uri] = { 'name': l:root_uri, 'uri': l:root_uri }
                            
                                if has_key(l:server_info, 'capabilities')
                                    let l:capabilities = l:server_info['capabilities']
                                else
                                    let l:capabilities = call(g:lsp_get_supported_capabilities[0], [l:server_info])
                                endif
                            
                                let l:request = {   'method': 'initialize',   'params': {     'processId': getpid(),     'clientInfo': { 'name': 'vim-lsp' },     'capabilities': l:capabilities,     'rootUri': l:root_uri,     'rootPath': lsp#utils#uri_to_path(l:root_uri),     'trace': 'off',   }, }
                                
                                let l:workspace_capabilities = get(l:capabilities, 'workspace', {})
                                if get(l:workspace_capabilities, 'workspaceFolders', v:false)
                                    " TODO: extract folder name for l:root_uri
                                    let l:server_info['workspaceFolders'] = [ { 'uri': l:root_uri, 'name': l:root_uri } ]
                                    let l:request['params']['workspaceFolders'] = l:server_info['workspaceFolders']
                                endif
                            
                                if has_key(l:server_info, 'initialization_options')
                                    let l:request.params['initializationOptions'] = l:server_info['initialization_options']
                                endif
                            
                                let l:server['init_callbacks'] = [a:cb]
                            
                                call s:send_request(a:server_name, l:request)

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:145
Called 15 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   15              0.000036   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*FugitiveHead')
   15              0.000009   endif
   15              0.000015   return s:has_fugitive

FUNCTION  lsp#capabilities#has_code_action_provider()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/capabilities.vim:72
Called 1 time
Total time:   0.000077
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000022   0.000012     let l:capabilities = lsp#get_server_capabilities(a:server_name)
    1              0.000004     if !empty(l:capabilities) && has_key(l:capabilities, 'codeActionProvider')
                                    if type(l:capabilities['codeActionProvider']) == type({})
                                        if has_key(l:capabilities['codeActionProvider'], 'codeActionKinds') && type(l:capabilities['codeActionProvider']['codeActionKinds']) == type([])
                                            return len(l:capabilities['codeActionProvider']['codeActionKinds']) != 0
                                        endif
                                    endif
    1              0.000000     endif
    1   0.000030   0.000007     return s:has_provider(a:server_name, 'codeActionProvider')

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:170
Called 15 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   15              0.000030   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   15              0.000004   endif
   15              0.000012   return ''

FUNCTION  <SNR>142_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 363 times
Total time:   0.001980
 Self time:   0.001980

count  total (s)   self (s)
  363              0.001871     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#extensions#lsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:34
Called 30 times
Total time:   0.006289
 Self time:   0.001246

count  total (s)   self (s)
   30              0.000122   if !exists(':LspDeclaration')
                                return ''
   30              0.000014   endif
                            
   30              0.000093   let error_symbol = get(g:, 'airline#extensions#lsp#error_symbol', 'E:')
   30              0.000149   let warning_symbol = get(g:, 'airline#extensions#lsp#warning_symbol', 'W:')
   30              0.000091   let show_line_numbers = get(g:, 'airline#extensions#lsp#show_line_numbers', 1)
                            
   30              0.000054   let is_err = a:type ==# 'error'
                            
   30              0.000063   let symbol = is_err ? error_symbol : warning_symbol
                            
   30   0.003184   0.000186   let num = lsp#get_buffer_diagnostics_counts()[a:type]
                            
   30              0.000040   if show_line_numbers == 1
   30   0.002389   0.000344     return s:airline_lsp_count(num, symbol) . <sid>airline_lsp_get_line_number(num, a:type)
                              else
                                return s:airline_lsp_count(num, symbol)
                              endif

FUNCTION  FugitiveActualDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:273
Called 15 times
Total time:   0.000707
 Self time:   0.000267

count  total (s)   self (s)
   15   0.000527   0.000087   let dir = call('FugitiveGitDir', a:000)
   15              0.000020   if empty(dir)
                                return ''
   15              0.000006   endif
   15              0.000037   if !has_key(s:resolved_git_dirs, dir)
                                let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
   15              0.000005   endif
   15              0.000052   return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:307
Called 9 times
Total time:   0.000169
 Self time:   0.000119

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    9              0.000065   let g:airline#visual_active = (mode() =~? '[vs]')
    9   0.000087   0.000037   call airline#update_tabline()

FUNCTION  lsp#ui#vim#folding#send_request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/folding.vim:54
Called 1 time
Total time:   0.000035
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000034   0.000007     if !lsp#capabilities#has_folding_range_provider(a:server_name)
    1              0.000000         return
                                endif
                            
                                if !g:lsp_fold_enabled
                                    call lsp#log('Skip sending fold request: folding was disabled explicitly')
                                    return
                                endif
                            
                                if has('textprop')
                                    call s:set_textprops(a:buf)
                                endif
                            
                                call lsp#send_request(a:server_name, { 'method': 'textDocument/foldingRange', 'params': {   'textDocument': lsp#get_text_document_identifier(a:buf) }, 'on_notification': function('s:handle_fold_request', [a:server_name]), 'sync': a:sync, 'bufnr': a:buf })

FUNCTION  <SNR>181_clear_all_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:86
Called 1 time
Total time:   0.000216
 Self time:   0.000188

count  total (s)   self (s)
    3              0.000006     for l:bufnr in range(1, bufnr('$'))
    2              0.000005         if bufexists(l:bufnr) && bufloaded(l:bufnr)
    2              0.000010             if has('nvim')
                                            call nvim_buf_clear_namespace(l:bufnr, s:namespace_id, 0, -1)
    2              0.000000             else
   10              0.000014                 for l:severity in keys(s:severity_sign_names_mapping)
    8              0.000005                     try
                                                    " TODO: need to check for valid range before calling prop_add
                                                    " See https://github.com/prabirshrestha/vim-lsp/pull/721
    8   0.000099   0.000071                         silent! call prop_remove({ 'type': s:get_prop_type_name(l:severity), 'bufnr': l:bufnr, 'all': v:true })
                                                catch
                                                    call lsp#log('diagnostics', 'clear_all_highlights', 'prop_remove', v:exception, v:throwpoint)
    8              0.000005                     endtry
   10              0.000006                 endfor
    2              0.000001             endif
    2              0.000001         endif
    3              0.000001     endfor

FUNCTION  <SNR>173_ensure_open()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:793
Called 1 time
Total time:   0.000918
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000003     let l:server = s:servers[a:server_name]
    1   0.000028   0.000004     let l:path = lsp#utils#get_buffer_uri(a:buf)
                            
    1              0.000001     if empty(l:path)
                                    let l:msg = s:new_rpc_success('ignore open since not a valid uri', { 'server_name': a:server_name, 'path': l:path })
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                    return
    1              0.000001     endif
                            
    1              0.000002     let l:buffers = l:server['buffers']
                            
    1              0.000002     if has_key(l:buffers, l:path)
    1   0.000012   0.000007         let l:msg = s:new_rpc_success('already opened', { 'server_name': a:server_name, 'path': l:path })
    1   0.000008   0.000002         call lsp#log(l:msg)
    1   0.000851   0.000002         call a:cb(l:msg)
    1              0.000001         return
                                endif
                            
                                if lsp#capabilities#has_workspace_folders_change_notifications(a:server_name)
                                    call s:workspace_add_folder(a:server_name)
                                endif
                            
                                call s:update_file_content(a:buf, a:server_name, lsp#utils#buffer#_get_lines(a:buf))
                            
                                let l:buffer_info = { 'changed_tick': getbufvar(a:buf, 'changedtick'), 'version': 1, 'uri': l:path }
                                let l:buffers[l:path] = l:buffer_info
                            
                                call s:send_notification(a:server_name, { 'method': 'textDocument/didOpen', 'params': {   'textDocument': s:get_text_document(a:buf, a:server_name, l:buffer_info) }, })
                            
                                call lsp#ui#vim#folding#send_request(a:server_name, a:buf, 0)
                            
                                let l:msg = s:new_rpc_success('textDocument/open sent', { 'server_name': a:server_name, 'path': l:path, 'filetype': getbufvar(a:buf, '&filetype') })
                                call lsp#log(l:msg)
                                call a:cb(l:msg)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:178
Called 9 times
Total time:   0.000690
 Self time:   0.000199

count  total (s)   self (s)
    9              0.000036   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
    9              0.000006   endif
    9              0.000003   try
    9   0.000605   0.000114     exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)
                              catch /^Vim\%((\a\+)\)\=:E48:/
                                " Catch: Sandbox mode
                                " no-op
    9              0.000007   endtry

FUNCTION  <SNR>174_emptySinkCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:196
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004     if a:t != 2 | return | endif
                                let a:data['disposed'] = 1

FUNCTION  lsp#capabilities#get_text_document_change_sync_kind()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/capabilities.vim:135
Called 1 time
Total time:   0.000031
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000011   0.000005     let l:capabilities = lsp#get_server_capabilities(a:server_name)
    1              0.000004     if !empty(l:capabilities) && has_key(l:capabilities, 'textDocumentSync')
    1              0.000003         if type(l:capabilities['textDocumentSync']) == type({})
                                        if  has_key(l:capabilities['textDocumentSync'], 'change') && type(l:capabilities['textDocumentSync']['change']) == type(1)
                                            let l:val = l:capabilities['textDocumentSync']['change']
                                            return l:val >= 0 && l:val <= 2 ? l:val : 1
                                        else
                                            return 1
                                        endif
    1              0.000002         elseif type(l:capabilities['textDocumentSync']) == type(1)
    1              0.000001             return l:capabilities['textDocumentSync']
                                    else
                                        return 1
                                    endif
                                endif
                                return 1

FUNCTION  <SNR>173_new_rpc_success()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:406
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000027     return { 'response': {   'message': a:message,   'data': extend({ '__data__': 'vim-lsp'}, a:data), } }

FUNCTION  <SNR>174_tapSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:260
Called 5 times
Total time:   0.003139
 Self time:   0.000073

count  total (s)   self (s)
    5   0.001907   0.000044     if a:t == 1 && has_key(a:data, 'next') | call a:data['next'](a:d) | endif
    5              0.000026     if a:t == 2 && lsp#callbag#isUndefined(a:d) && has_key(a:data, 'complete') | call a:data['complete']() | endif
    5              0.000019     if a:t == 2 && !lsp#callbag#isUndefined(a:d) && has_key(a:data, 'error') | call a:data['error'](a:d) | endif
    5   0.000430   0.000032     call a:data['sink'](a:t, a:d)

FUNCTION  <SNR>173_send_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:864
Called 1 time
Total time:   0.000196
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003     let l:lsp_id = s:servers[a:server_name]['lsp_id']
    1              0.000002     let l:data = copy(a:data)
    1              0.000002     if has_key(l:data, 'on_notification')
                                    let l:data['on_notification'] = '---funcref---'
    1              0.000000     endif
    1   0.000010   0.000006     call lsp#log_verbose('--->', l:lsp_id, a:server_name, l:data)
    1   0.000177   0.000005     call lsp#client#send_notification(l:lsp_id, a:data)

FUNCTION  <SNR>175_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/signature_help.vim:115
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000004     let l:bufnr = bufnr('%')
    1              0.000003     call timer_stop(s:debounce_timer_id)
    1              0.000002     if g:lsp_signature_help_enabled
    1              0.000010         let s:debounce_timer_id = timer_start(g:lsp_signature_help_delay, function('s:on_text_changed_after', [l:bufnr]), { 'repeat': 1 })
    1              0.000000     endif

FUNCTION  <SNR>174_createNext()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:143
Called 1 time
Total time:   0.000320
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000319   0.000008     if !a:data['end'] | call a:data['sink'](1, a:d) | endif

FUNCTION  <SNR>174_subscribeSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:611
Called 5 times
Total time:   0.000559
 Self time:   0.000139

count  total (s)   self (s)
    5              0.000015     if a:t == 0 | let a:data['talkback'] = a:d | endif
    5   0.000112   0.000026     if a:t == 1 && has_key(a:data, 'next') | call a:data['next'](a:d) | endif
    5   0.000390   0.000056     if a:t == 1 || a:t == 0 | call a:data['talkback'](1, lsp#callbag#undefined()) | endif
    5              0.000020     if a:t == 2 && lsp#callbag#isUndefined(a:d) && has_key(a:data, 'complete') | call a:data['complete']() | endif
    5              0.000017     if a:t == 2 && !lsp#callbag#isUndefined(a:d) && has_key(a:data, 'error') | call a:data['error'](a:d) | endif

FUNCTION  <SNR>174_createSinkCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:134
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000003     if !a:data['end']
    2              0.000004         let a:data['end'] = (a:t == 2)
    2              0.000007         if a:data['end'] && has_key(a:data, 'clean') && type(a:data['clean']) == type(function('s:noop'))
                                        call a:data['clean']()
    2              0.000000         endif
    3              0.000001     endif

FUNCTION  <SNR>173_is_step_error()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:398
Called 5 times
Total time:   0.000128
 Self time:   0.000037

count  total (s)   self (s)
    5   0.000124   0.000033     return lsp#client#is_error(a:s.result[0]['response'])

FUNCTION  <SNR>181_clear_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:109
Called 1 time
Total time:   0.000222
 Self time:   0.000006

count  total (s)   self (s)
                                " TODO: optimize by looking at params
    1   0.000221   0.000005     call s:clear_all_highlights()

FUNCTION  lsp#callbag#isNextNotification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1438
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000006     return a:d['kind'] ==# 'N'

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:13
Called 15 times
Total time:   0.000410
 Self time:   0.000410

count  total (s)   self (s)
   15              0.000043   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  endif
                                catch
                                endtry
   15              0.000008   endif
                            
   15              0.000050   let fmod = (exists("+autochdir") && &autochdir) ? ':p' : ':.'
   15              0.000019   let result=''
   15              0.000025   if empty(b:fugitive_name)
   15              0.000047     if empty(bufname('%'))
                                  return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
   15              0.000006     endif
   15              0.000048     return s:has_percent_eval ? '%f' : fnamemodify(bufname('%'), fmod)
                              else
                                return s:has_percent_eval ? '%f [git]' : (fnamemodify(b:fugitive_name, fmod). " [git]")
                              endif

FUNCTION  lsp#callbag#takeUntil()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1001
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000006     let l:data = { 'notifier': a:notfier }
    2              0.000007     return function('s:takeUntilNotifier', [l:data])

FUNCTION  <SNR>145_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 15 times
Total time:   0.004837
 Self time:   0.000645

count  total (s)   self (s)
   45              0.000094   for vcs in keys(s:vcs_config)
   30   0.004407   0.000215     call {s:vcs_config[vcs].update_branch}()
   30              0.000093     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
   30              0.000014     endif
   45              0.000027   endfor

FUNCTION  <SNR>230_get_fixendofline()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/buffer.vim:3
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000003     let l:eol = getbufvar(a:buf, '&endofline')
    1              0.000003     let l:binary = getbufvar(a:buf, '&binary')
                            
    1              0.000001     if s:fixendofline_exists
    1              0.000003         let l:fixeol = getbufvar(a:buf, '&fixendofline')
                            
    1              0.000001         if !l:binary
                                        " When 'binary' is off and 'fixeol' is on, 'endofline' is not used
                                        "
                                        " When 'binary' is off and 'fixeol' is off, 'endofline' is used to
                                        " remember the presence of a <EOL>
    1              0.000001             return l:fixeol || l:eol
                                    else
                                        " When 'binary' is on, the value of 'fixeol' doesn't matter
                                        return l:eol
                                    endif
                                else
                                    " When 'binary' is off the value of 'endofline' is not used
                                    "
                                    " When 'binary' is on 'endofline' is used to remember the presence of
                                    " a <EOL>
                                    return !l:binary || l:eol
                                endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:18
Called 30 times
Total time:   0.000983
 Self time:   0.000983

count  total (s)   self (s)
   30              0.000049   if v:version < 704
                                return ''
   30              0.000113   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
   30              0.000061     if exists('g:fugitive_event')
                                  return g:fugitive_event
   30              0.000023     endif
   30              0.000072     let dir = get(b:, 'git_dir', '')
   30              0.000096     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   30              0.000203     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(bufnr(''))
                                  return b:git_dir
   30              0.000009     endif
   30              0.000127     return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(a:1)
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                              else
                                return ''
                              endif

FUNCTION  lsp#utils#get_buffer_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:179
Called 54 times
Total time:   0.001377
 Self time:   0.001084

count  total (s)   self (s)
   54              0.000229     let l:name = a:0 > 0 ? bufname(a:1) : expand('%')
   54              0.000093     if empty(l:name)
                                    let l:nr = a:0 > 0 ? a:1 : bufnr('%')
                                    let l:name = printf('%s/__NO_NAME_%d__', getcwd(), l:nr)
   54              0.000026     endif
   54   0.000772   0.000479     return lsp#utils#path_to_uri(fnamemodify(l:name, ':p'))

FUNCTION  <SNR>142_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 237 times
Total time:   0.005276
 Self time:   0.005276

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  237              0.000747     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  237              0.000156     endif
  237              0.000681     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
  237              0.000144     endif
                            
  237              0.000527     for val in a:colors
  237              0.000586       if !empty(val) && val !=# 'NONE'
  237              0.000283         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  lsp#utils#to_char()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:313
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000006     let l:lines = getbufline(a:expr, a:lnum)
    1              0.000002     if l:lines == []
                                    if type(a:expr) != v:t_string || !filereadable(a:expr)
                                        " invalid a:expr
                                        return a:col - 1
                                    endif
                                    " a:expr is a file that is not yet loaded as a buffer
                                    let l:lines = readfile(a:expr, '', a:lnum)
    1              0.000000     endif
    1              0.000003     let l:linestr = l:lines[-1]
    1              0.000005     return strchars(strpart(l:linestr, 0, a:col - 1))

FUNCTION  <SNR>145_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:148
Called 15 times
Total time:   0.000825
 Self time:   0.000723

count  total (s)   self (s)
   15   0.000167   0.000065   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   15              0.000008   else
   15              0.000032     let s:vcs_config['mercurial'].branch = ''
   15              0.000006   endif

FUNCTION  <SNR>174_materializeF()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1400
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000005     let a:data['source'] = a:source
    2              0.000037     return function('s:materializeFSource', [a:data])

FUNCTION  <SNR>174_distinctUntilChangedSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:982
Called 3 times
Total time:   0.004946
 Self time:   0.000114

count  total (s)   self (s)
    3              0.000017     if a:t == 0 | let a:data['talkback'] = a:d | endif
    3              0.000003     if a:t != 1
                                    call a:data['sink'](a:t, a:d)
                                    return
    3              0.000001     endif
                            
    3   0.000039   0.000026     if a:data['inited'] && has_key(a:data, 'prev') && a:data['compare'](a:data['prev'], a:d)
                                    call a:data['talkback'](1, lsp#callbag#undefined())
                                    return
    3              0.000001     endif
                            
    3              0.000007     let a:data['inited'] = 1
    3              0.000008     let a:data['prev'] = a:d
    3   0.004839   0.000020     call a:data['sink'](1, a:d)

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:69
Called 15 times
Total time:   0.000912
 Self time:   0.000421

count  total (s)   self (s)
   15              0.000073   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   15              0.000005   endif
   15   0.000594   0.000103   return {b:source_func}()

FUNCTION  lsp#get_server_capabilities()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:106
Called 5 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    5              0.000012     let l:server = s:servers[a:server_name]
    5              0.000025     return has_key(l:server, 'init_result') ? l:server['init_result']['result']['capabilities'] : {}

FUNCTION  airline#extensions#lsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:56
Called 15 times
Total time:   0.002500
 Self time:   0.000090

count  total (s)   self (s)
   15   0.002491   0.000081   return airline#extensions#lsp#get('warning')

FUNCTION  lsp#callbag#createCompleteNotification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1430
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000005     return { 'kind': 'C' }

FUNCTION  matchup#pos#equal()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/pos.vim:106
Called 2 times
Total time:   0.000197
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000095   0.000018   let l:pos1 = s:parse_args(a:p1)
    2   0.000089   0.000010   let l:pos2 = s:parse_args(a:p2)
    2              0.000011   return l:pos1[:1] == l:pos2[:1]

FUNCTION  <SNR>174_filterCondition()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:436
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000007     let a:data['source'] = a:source
    2              0.000011     return function('s:filterConditionSource', [a:data])

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:206
Called 15 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
   15              0.000033   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   15              0.000008   endif

FUNCTION  <SNR>181_get_prop_type_name()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:82
Called 8 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    8              0.000026     return s:namespace_id . '_' . get(s:severity_sign_names_mapping, a:severity, 'LspError')

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 30 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   30              0.000091   return get(s:parts, a:key, {})

FUNCTION  <SNR>174_takeUntilNotifier()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1006
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000005     let a:data['source'] = a:source
    2              0.000008     return function('s:takeUntilFactory', [a:data])

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 15 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   15              0.000035   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>147_airline_lsp_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:15
Called 30 times
Total time:   0.001981
 Self time:   0.000299

count  total (s)   self (s)
   30              0.000038   let result = ''
                            
   30              0.000042   if a:type ==# 'error'
   15   0.001757   0.000075     let result = lsp#get_buffer_first_error_line()
   30              0.000019   endif
                            
   30              0.000046   if empty(result)
   30              0.000028       return ''
                              endif
                            
                              let open_lnum_symbol  = get(g:, 'airline#extensions#lsp#open_lnum_symbol', '(L')
                              let close_lnum_symbol = get(g:, 'airline#extensions#lsp#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . result . close_lnum_symbol

FUNCTION  lsp#client#is_error()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:310
Called 9 times
Total time:   0.000153
 Self time:   0.000055

count  total (s)   self (s)
    9   0.000151   0.000053     return s:lsp_is_error(a:obj_or_response)

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 237 times
Total time:   0.066472
 Self time:   0.020853

count  total (s)   self (s)
  237              0.000404     if pumvisible()
                                  return
  237              0.000134     endif
  237              0.000395     let colors = a:colors
  237              0.000458     if len(colors) == 4
   63              0.000133       call add(colors, '')
  237              0.000125     endif
                                " colors should always be string values
  237              0.004404     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  237              0.000320     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  237              0.000153     endif
  237   0.038486   0.001571     let old_hi = airline#highlighter#get_highlight(a:group)
  237              0.001908     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  237   0.006706   0.001430     let colors = s:CheckDefined(colors)
  237   0.004376   0.001506     if old_hi != new_hi || !s:hl_group_exists(a:group)
    6   0.000601   0.000043       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
    6              0.000004       try
    6              0.000050         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
    6              0.000005       endtry
    6              0.000016       if has_key(s:hl_groups, a:group)
    6              0.000012         let s:hl_groups[a:group] = colors
    6              0.000003       endif
  237              0.000142     endif

FUNCTION  <SNR>217_out_cb()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/job.vim:57
Called 3 times
Total time:   0.005538
 Self time:   0.000027

count  total (s)   self (s)
    3   0.005536   0.000025     call a:opts.on_stdout(a:jobid, a:data, 'stdout')

FUNCTION  <SNR>177_set_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:72
Called 1 time
Total time:   0.000064
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000003     let l:bufnr = bufnr('%')
                            
    1   0.000028   0.000005     call s:clear_highlights()
                            
    1              0.000003     if mode() !=# 'n' | return | endif
                            
    1   0.000022   0.000005     if lsp#client#is_error(a:data['response']) | return | endif
                            
                                " Get references from the response
    1              0.000002     let l:reference_list = a:data['response']['result']
    1              0.000001     if empty(l:reference_list)
    1              0.000000         return
                                endif
                            
                                " Convert references to vim positions
                                let l:position_list = []
                                for l:reference in l:reference_list
                                    call extend(l:position_list, lsp#utils#range#lsp_to_vim(l:bufnr, l:reference['range']))
                                endfor
                            
                                call sort(l:position_list, function('s:compare_positions'))
                            
                                " Ignore response if the cursor is not over a reference anymore
                                if s:in_reference(l:position_list) == -1 | return | endif
                            
                                " Store references
                                if s:use_vim_textprops
                                    let b:lsp_reference_positions = l:position_list
                                    let b:lsp_reference_matches = []
                                else
                                    let w:lsp_reference_positions = l:position_list
                                    let w:lsp_reference_matches = []
                                endif
                            
                                " Apply highlights to the buffer
                                call s:init_reference_highlight(l:bufnr)
                                if s:use_vim_textprops
                                    for l:position in l:position_list
                                        try
                                            " TODO: need to check for valid range before calling prop_add
                                            " See https://github.com/prabirshrestha/vim-lsp/pull/721
                                            silent! call prop_add(l:position[0], l:position[1], { 'id': s:prop_id, 'bufnr': l:bufnr, 'length': l:position[2], 'type': 'vim-lsp-reference-highlight'})
                                            call add(b:lsp_reference_matches, l:position[0])
                                        catch
                                            call lsp#log('document_highlight', 'set_highlights', v:exception, v:throwpoint)
                                        endtry
                                    endfor
                                else
                                    for l:position in l:position_list
                                        let l:match = matchaddpos('lspReference', [l:position], -5)
                                        call add(w:lsp_reference_matches, l:match)
                                    endfor
                                endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 15 times
Total time:   0.001963
 Self time:   0.001564

count  total (s)   self (s)
   15              0.000052   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   15              0.000082   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   15              0.000004   endif
   15              0.000077   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   15              0.000044   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
   15              0.000011   endif
   15   0.000474   0.000075   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>179_on_text_documentation_publish_diagnostics()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:98
Called 1 time
Total time:   0.001121
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000022   0.000006     if lsp#client#is_error(a:response) | return | endif
    1   0.000008   0.000006     let l:normalized_uri = lsp#utils#normalize_uri(a:response['params']['uri'])
    1              0.000003     if !has_key(s:diagnostics_state, l:normalized_uri)
                                    let s:diagnostics_state[l:normalized_uri] = {}
    1              0.000000     endif
    1              0.000006     let s:diagnostics_state[l:normalized_uri][a:server] = a:response
    1   0.001080   0.000008     call s:notify_diagnostics_update(a:server, l:normalized_uri)

FUNCTION  <SNR>179_notify_diagnostics_update()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:128
Called 1 time
Total time:   0.001072
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004     let l:data = { 'server': '$vimlsp', 'response': { 'method': '$/vimlsp/lsp_diagnostics_updated', 'params': {} } }
                                " if a:0 > 0 | let l:data['response']['params']['server'] = a:1 | endif
                                " if a:0 > 1 | let l:data['response']['params']['uri'] = a:2 | endif
    1   0.001020   0.000003     call lsp#stream(1, l:data)
    1   0.000045   0.000007     doautocmd <nomodeline> User lsp_diagnostics_updated

FUNCTION  lsp#callbag#create()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:112
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002     let l:data = {}
    1              0.000001     if a:0 > 0
    1              0.000003         let l:data['prod'] = a:1
    1              0.000001     endif
    1              0.000004     return function('s:createProd', [l:data])

FUNCTION  lsp#utils#buffer#_get_lines()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/buffer.vim:33
Called 1 time
Total time:   0.000031
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006     let l:lines = getbufline(a:buf, 1, '$')
    1   0.000020   0.000004     if s:get_fixendofline(a:buf)
    1              0.000003         let l:lines += ['']
    1              0.000000     endif
    1              0.000001     return l:lines

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:204
Called 15 times
Total time:   0.000369
 Self time:   0.000085

count  total (s)   self (s)
   15   0.000362   0.000078   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  lsp#utils#path_to_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:114
Called 54 times
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
   54              0.000151         if has_key(s:path_to_uri_cache, a:path)
   54              0.000108             return s:path_to_uri_cache[a:path]
                                    endif
                            
                                    if empty(a:path) || lsp#utils#is_remote_uri(a:path)
                                        let s:path_to_uri_cache[a:path] = a:path
                                        return s:path_to_uri_cache[a:path]
                                    else
                                        let s:path_to_uri_cache[a:path] = s:encode_uri(a:path, 0, 'file://')
                                        return s:path_to_uri_cache[a:path]
                                    endif

FUNCTION  lsp#get_position()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1068
Called 1 time
Total time:   0.000043
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003     let l:line = line('.')
    1   0.000037   0.000011     let l:char = lsp#utils#to_char('%', l:line, col('.'))
    1              0.000003     return { 'line': l:line - 1, 'character': l:char }

FUNCTION  <SNR>202_get_content_length()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:138
Called 3 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    3              0.000017     for l:header in split(a:headers, "\r\n")
    3              0.000011         let l:kvp = split(l:header, ':')
    3              0.000006         if len(l:kvp) == 2
    3              0.000017             if l:kvp[0] =~? '^Content-Length'
    3              0.000008                 return str2nr(l:kvp[1], 10)
                                        endif
                                    endif
                                endfor
                                return -1

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:145
Called 15 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
   15              0.000138   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   15              0.000076   if g:airline_detect_spell && (&spell || (exists('g:airline_spell_check_command') && eval(g:airline_spell_check_command)))
                            
                                if g:airline_detect_spelllang !=? '0' && g:airline_detect_spelllang ==? 'flag'
                                  let spelllang = tolower(&spelllang)
                                  if has_key(s:flags, spelllang)
                                    return s:flags[spelllang]
                                  elseif has_key(s:flags_noregion, spelllang)
                                    return s:flags_noregion[spelllang]
                                  endif
                                endif
                            
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                elseif !empty(g:airline_symbols.spell)
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   15              0.000005   endif
   15              0.000013   return ''

FUNCTION  <SNR>173_request_send()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1135
Called 1 time
Total time:   0.000205
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     if a:ctx['cancelled'] | return | endif " caller already unsubscribed so don't bother sending request
    1   0.000202   0.000007     let a:ctx['request_id'] = s:send_request(a:ctx['server_name'], a:ctx['request'])

FUNCTION  matchup#loader#refresh_match_words()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/loader.vim:107
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000007   if get(b:, 'match_words', ':') !~# ':'
                                call matchup#perf#tic('refresh')
                            
                                " protect the cursor from the match_words function
                                let l:save_pos = matchup#pos#get_cursor()
                                let l:match_words = ''
                                execute 'let l:match_words =' b:match_words
                                if l:save_pos != matchup#pos#get_cursor()
                                  call matchup#pos#set_cursor(l:save_pos)
                                endif
                            
                                call matchup#perf#toc('refresh', 'function')
                            
                                if has_key(s:match_word_cache, l:match_words)
                                  let b:matchup_delim_lists = s:match_word_cache[l:match_words].delim_lists
                                  let b:matchup_delim_re = s:match_word_cache[l:match_words].delim_regexes
                                  call matchup#perf#toc('refresh', 'cache_hit')
                                else
                                  " re-parse match words
                                  let b:matchup_delim_lists = s:init_delim_lists(0, 0)
                                  let b:matchup_delim_re = s:init_delim_regexes()
                                  let s:match_word_cache[l:match_words] = { 'delim_lists'  : b:matchup_delim_lists, 'delim_regexes': b:matchup_delim_re,}
                                  call matchup#perf#toc('refresh', 'parse')
                                endif
    1              0.000001   endif

FUNCTION  <SNR>173_add_didchange_queue()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1218
Called 1 time
Total time:   0.000046
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000002     if g:lsp_use_event_queue == 0
                                    for l:server_name in lsp#get_allowed_servers(a:buf)
                                        call s:ensure_flush(a:buf, l:server_name, function('s:Noop'))
                                    endfor
                                    return
    1              0.000001     endif
    1              0.000003     if index(s:didchange_queue, a:buf) == -1
    1              0.000003         call add(s:didchange_queue, a:buf)
    1              0.000001     endif
    1   0.000014   0.000008     call lsp#log('s:send_didchange_queue() will be triggered')
    1              0.000002     call timer_stop(s:didchange_timer)
    1              0.000003     let l:lazy = &updatetime > 1000 ? &updatetime : 1000
    1              0.000007     let s:didchange_timer = timer_start(l:lazy, function('s:send_didchange_queue'))

FUNCTION  <SNR>174_materializeFSource()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1405
Called 2 times
Total time:   0.003350
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000005     if a:start != 0 | return | endif
    2              0.000005     let a:data['sink'] = a:sink
    2   0.003339   0.000019     call a:data['source'](0, function('s:materializeFSourceCallback', [a:data]))

FUNCTION  <SNR>174_switchMapInputSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1306
Called 2 times
Total time:   0.004498
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000006     if a:t == 0 | call a:data['outputSink'](a:t, a:d) | endif
    2              0.000001     if a:t == 1
    2              0.000004         if has_key(a:data, 'currSourceTalkback')
                                        call a:data['currSourceTalkback'](2, lsp#callbag#undefined())
                                        call remove(a:data, 'currSourceTalkback')
    2              0.000001         endif
    2   0.000973   0.000013         let l:CurrSource = a:data['makeSource'](a:d)
    2   0.003485   0.000024         call l:CurrSource(0, function('s:switchMapCurrSourceCallback', [a:data, a:t, a:d]))
    2              0.000000     endif
    2              0.000003     if a:t == 2
                                    let a:data['sourceEnded'] = 1
                                    if !has_key(a:data, 'currSourceTalkback') | call a:data['outputSink'](a:t, a:d) | endif
    2              0.000001     endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:249
Called 15 times
Total time:   0.006383
 Self time:   0.000356

count  total (s)   self (s)
   15              0.000044   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   15              0.000011   endif
                            
   15   0.004914   0.000077   call s:update_branch()
   15   0.001276   0.000086   call s:update_untracked()
                            
   15              0.000055   if exists('b:airline_head') && !empty(b:airline_head)
   15              0.000016     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  lsp#utils#normalize_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:166
Called 51 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   51              0.000056         return a:uri

FUNCTION  <SNR>174_takeUntilSinkCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1063
Called 3 times
Total time:   0.000070
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000011     if a:data['done'] != s:takeUntilUniqueToken | return | endif
    3              0.000016     if a:t == 2 && has_key(a:data, 'notifierTalkback') && a:data['notifierTalkback'] != 0 | call a:data['notifierTalkback'](2, lsp#callbag#undefined()) | endif
    3   0.000041   0.000018     call a:data['sourceTalkback'](a:t, a:d)

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 15 times
Total time:   0.000528
 Self time:   0.000105

count  total (s)   self (s)
   15   0.000523   0.000100   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  lsp#callbag#isUndefined()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:11
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007     return type(a:d) == s:str_type && a:d ==# s:undefined_token

FUNCTION  <SNR>174_makeSubjectSinkCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:93
Called 25 times
Total time:   0.000291
 Self time:   0.000291

count  total (s)   self (s)
   25              0.000026     if a:t == 2
                                    let l:i = -1
                                    let l:found = 0
                                    for l:Item in a:data['sinks']
                                        let l:i += 1
                                        if l:Item == a:Sink
                                            let l:found = 1
                                            break
                                        endif
                                    endfor
                                    if l:found
                                        call remove(a:data['sinks'], l:i)
                                    endif
   25              0.000012     endif

FUNCTION  <SNR>216_next()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/step.vim:1
Called 8 times
Total time:   0.007246
 Self time:   0.000017

count  total (s)   self (s)
    8              0.000016     if len(a:steps) == a:current_index
                                    return
    8              0.000002     endif
    8              0.000023     let l:Step = a:steps[a:current_index]
    8              0.000046     let l:ctx = { 'callback': function('s:callback', [a:steps, a:current_index]), 'result': a:result }
    8   0.001227   0.000987     call call(l:Step, [l:ctx])

FUNCTION  <SNR>202_lsp_send()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:213
Called 2 times
Total time:   0.000327
 Self time:   0.000178

count  total (s)   self (s)
    2              0.000009     let l:ctx = get(s:clients, a:id, {})
    2              0.000004     if empty(l:ctx)
                                    return -1
    2              0.000000     endif
                            
    2              0.000004     let l:request = { 'jsonrpc': '2.0' }
                            
    2              0.000003     if (a:type == s:send_type_request)
    1              0.000003         let l:ctx['request_sequence'] = l:ctx['request_sequence'] + 1
    1              0.000002         let l:request['id'] = l:ctx['request_sequence']
    1              0.000003         let l:ctx['requests'][l:request['id']] = l:request
    1              0.000002         if has_key(a:opts, 'on_notification')
    1              0.000003             let l:ctx['on_notifications'][l:request['id']] = a:opts['on_notification']
    1              0.000001         endif
    2              0.000000     endif
                            
    2              0.000003     if has_key(a:opts, 'id')
                                    let l:request['id'] = a:opts['id']
    2              0.000002     endif
    2              0.000003     if has_key(a:opts, 'method')
    2              0.000005         let l:request['method'] = a:opts['method']
    2              0.000000     endif
    2              0.000004     if has_key(a:opts, 'params')
    2              0.000004         let l:request['params'] = a:opts['params']
    2              0.000000     endif
    2              0.000004     if has_key(a:opts, 'result')
                                    let l:request['result'] = a:opts['result']
    2              0.000001     endif
    2              0.000003     if has_key(a:opts, 'error')
                                    let l:request['error'] = a:opts['error']
    2              0.000001     endif
                            
    2              0.000009     let l:json = json_encode(l:request)
    2              0.000042     let l:payload = 'Content-Length: ' . len(l:json) . "\r\n\r\n" . l:json
                            
    2   0.000160   0.000011     call lsp#utils#job#send(a:id, l:payload)
                            
    2              0.000004     if (a:type == s:send_type_request)
    1              0.000002         let l:id = l:request['id']
    1              0.000002         if get(a:opts, 'sync', 0) !=# 0
                                        let l:timeout = get(a:opts, 'sync_timeout', -1)
                                        if lsp#utils#_wait(l:timeout, {-> !has_key(l:ctx['requests'], l:request['id'])}, 1) == -1
                                            throw 'lsp#client: timeout'
                                        endif
    1              0.000000         endif
    1              0.000001         return l:id
    1              0.000001     else
    1              0.000000         return 0
                                endif

FUNCTION  <SNR>174_mergeSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:805
Called 5 times
Total time:   0.000486
 Self time:   0.000181

count  total (s)   self (s)
    5              0.000008     if a:t == 0
                                    call insert(a:data['sourceTalkbacks'], a:d, a:i)
                                    let a:data['startCount'] += 1
                                    if a:data['startCount'] == 1 | call a:data['sink'](0, a:data['talkback']) | endif
    5              0.000010     elseif a:t == 2 && !lsp#callbag#isUndefined(a:d)
                                    let a:data['ended'] = 1
                                    let l:j = 0
                                    while l:j < a:data['n']
                                        if l:j != a:i && l:j < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:j] != 0
                                            call a:data['sourceTalkbacks'][l:j](2, lsp#callbag#undefined())
                                        endif
                                        let l:j += 1
                                    endwhile
                                    call a:data['sink'](2, a:d)
    5              0.000006     elseif a:t == 2
                                    let a:data['sourceTalkbacks'][a:i] = 0
                                    let a:data['endCount'] += 1
                                    if a:data['endCount'] == a:data['n'] | call a:data['sink'](2, lsp#callbag#undefined()) | endif
    5              0.000002     else
    5   0.000336   0.000031         call a:data['sink'](a:t, a:d)
    5              0.000001     endif

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:218
Called 19 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   19              0.000108   if has_key(s:contexts, a:winnr)
   19              0.000115     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>174_debounceTimeTimerCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:586
Called 5 times
Total time:   0.006228
 Self time:   0.000114

count  total (s)   self (s)
    5   0.006220   0.000106     call a:data['sink'](1, a:d)

FUNCTION  <lambda>17()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return g:lsp_document_highlight_enabled

FUNCTION  <lambda>19()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                            return a['bufnr'] == b['bufnr'] && a['curpos'] == b['curpos'] && a['changedtick'] == b['changedtick']

FUNCTION  lsp#utils#iteratable()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:504
Called 48 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
   48              0.000146     return type(a:list) !=# v:t_list ? [] : a:list

FUNCTION  lsp#utils#get_buffer_path()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:175
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012     return expand((a:0 > 0 ? '#' . a:1 : '%') . ':p')

FUNCTION  <lambda>20()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return mode() is# 'n' && getbufvar(bufnr('%'), '&buftype') !=# 'terminal'

FUNCTION  <lambda>21()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000538
 Self time:   0.000047

count  total (s)   self (s)
                            return lsp#callbag#pipe(       s:send_highlight_request(),       lsp#callbag#materialize(),       lsp#callbag#filter({x->lsp#callbag#isNextNotification(x)}),       lsp#callbag#map({x->x['value']}),       lsp#callbag#takeUntil(           lsp#callbag#fromEvent('BufLeave')       )   ) 

FUNCTION  <lambda>22()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return mode() is# 'n'

FUNCTION  <lambda>23()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000069
 Self time:   0.000005

count  total (s)   self (s)
                            return s:set_highlights(x)

FUNCTION  <lambda>24()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:42
Called 4 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>25()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:42
Called 1 time
Total time:   0.001132
 Self time:   0.000011

count  total (s)   self (s)
                            return s:on_text_documentation_publish_diagnostics(x['server'], x['response'])

FUNCTION  <lambda>26()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:42
Called 4 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit'

FUNCTION  <lambda>28()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return g:lsp_diagnostics_echo_cursor

FUNCTION  <lambda>29()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
                            return {'bufnr': bufnr('%'), 'curpos': getcurpos()[0:2], 'changedtick': b:changedtick }

FUNCTION  <SNR>174_takeUntilFactory()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1013
Called 2 times
Total time:   0.003461
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000007     if a:start != 0 | return | endif
    2              0.000005     let a:data['sink'] = a:sink
    2              0.000003     let a:data['inited'] = 1
    2              0.000003     let a:data['sourceTalkback'] = 0
    2              0.000004     let a:data['notiferTalkback'] = 0
    2              0.000006     let a:data['done'] = s:takeUntilUniqueToken
    2   0.003430   0.000025     call a:data['source'](0, function('s:takeUntilSourceCallback', [a:data]))

FUNCTION  <SNR>195_send_request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:64
Called 1 time
Total time:   0.000210
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000194   0.000016     let l:servers = filter(lsp#get_allowed_servers(), 'lsp#capabilities#has_code_action_provider(v:val)')
                            
    1              0.000002     if empty(l:servers)
    1   0.000012   0.000005         return lsp#callbag#empty()
                                endif
                            
                                let l:range = lsp#utils#range#_get_current_line_range()
                                return lsp#callbag#pipe( lsp#callbag#fromList(l:servers), lsp#callbag#flatMap({server->   lsp#request(server, {       'method': 'textDocument/codeAction',       'params': {           'textDocument': lsp#get_text_document_identifier(),           'range': l:range,           'context': {               'diagnostics': [],               'only': ['', 'quickfix', 'refactor', 'refactor.extract', 'refactor.inline', 'refactor.rewrite'],           }       }   }) }), lsp#callbag#filter({x-> !lsp#client#is_error(x['response']) && !empty(x['response']['result'])}), lsp#callbag#take(1), )

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:30
Called 45 times
Total time:   0.001203
 Self time:   0.000746

count  total (s)   self (s)
   45   0.000773   0.000316   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
   45              0.000026   else
   45              0.000044     return a:text
                              endif

FUNCTION  lsp#stream()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1101
Called 4 times
Total time:   0.004929
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000005     if a:0 == 0
                                    return lsp#callbag#share(s:Stream)
    4              0.000001     else
    4   0.002915   0.000175         call s:Stream(a:1, a:2)
    4              0.000001     endif

FUNCTION  <SNR>174_switchMapDefaultCombineResults()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1290
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return a:b

FUNCTION  <SNR>174_createComplete()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:154
Called 1 time
Total time:   0.000535
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001     if !a:data['end']
    1              0.000002         let a:data['end'] = 1
    1   0.000531   0.000006         call a:data['sink'](2, lsp#callbag#undefined())
    1              0.000001     endif

FUNCTION  lsp#utils#job#send()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/job.vim:365
Called 2 times
Total time:   0.000149
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000008     let l:opts = get(a:000, 0, {})
    2   0.000140   0.000016     call s:job_send(a:jobid, a:data, l:opts)

FUNCTION  <lambda>30()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                            return a['bufnr'] == b['bufnr'] && a['curpos'] == b['curpos'] && a['changedtick'] == b['changedtick']

FUNCTION  <lambda>31()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return mode() is# 'n'

FUNCTION  <lambda>32()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                            return getbufvar(bufnr('%'), '&buftype') !=# 'terminal'

FUNCTION  <lambda>33()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000144
 Self time:   0.000008

count  total (s)   self (s)
                            return lsp#internal#diagnostics#under_cursor#get_diagnostic()

FUNCTION  <lambda>34()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:11
Called 1 time
Total time:   0.000017
 Self time:   0.000004

count  total (s)   self (s)
                            return s:echo(x)

FUNCTION  <lambda>35()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:49
Called 4 times
Total time:   0.000041
 Self time:   0.000026

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')       && has_key(x['response'], 'method') && x['response']['method'] ==# '$/vimlsp/lsp_diagnostics_updated'       && !lsp#client#is_error(x['response'])

FUNCTION  <lambda>36()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:49
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x['response']['params']

FUNCTION  <lambda>39()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:49
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return g:lsp_diagnostics_highlights_enabled

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 9 times
Total time:   0.003390
 Self time:   0.000271

count  total (s)   self (s)
    9              0.000037     if getbufvar(a:bufnr, '&modified')
    4              0.000035       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    5              0.000004     else
    5              0.000044       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    9              0.000004     endif
                            
    9              0.000016     if !empty(colors)
    9   0.003195   0.000076       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    9              0.000003     endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:318
Called 15 times
Total time:   0.007295
 Self time:   0.000481

count  total (s)   self (s)
   15   0.006465   0.000082   let head = airline#extensions#branch#head()
   15   0.000147   0.000097   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   15              0.000049   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   15   0.000463   0.000082   let head = airline#util#shorten(head, winwidth, minwidth)
   15              0.000054   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   15              0.000104   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <lambda>40()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:49
Called 1 time
Total time:   0.000227
 Self time:   0.000005

count  total (s)   self (s)
                            return s:clear_highlights(x)

FUNCTION  <lambda>41()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:49
Called 1 time
Total time:   0.000214
 Self time:   0.000006

count  total (s)   self (s)
                            return s:set_highlights(x)

FUNCTION  <lambda>44()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:41
Called 4 times
Total time:   0.000039
 Self time:   0.000025

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')       && has_key(x['response'], 'method') && x['response']['method'] ==# '$/vimlsp/lsp_diagnostics_updated'       && !lsp#client#is_error(x['response'])

FUNCTION  <lambda>45()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:41
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x['response']['params']

FUNCTION  <lambda>48()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:41
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return g:lsp_diagnostics_signs_enabled

FUNCTION  <lambda>49()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:41
Called 1 time
Total time:   0.000028
 Self time:   0.000012

count  total (s)   self (s)
                            return s:clear_signs(x)

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 15 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
   15              0.000059   let ggvars = getbufvar(a:buffer, 'gitgutter')
   15              0.000067   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   15              0.000028     return ggvars[a:varname]
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  lsp#log_verbose()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:39
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000006     if g:lsp_log_verbose
                                    call call(function('lsp#log'), a:000)
    5              0.000003     endif

FUNCTION  <lambda>50()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:41
Called 1 time
Total time:   0.000262
 Self time:   0.000005

count  total (s)   self (s)
                            return s:set_signs(x)

FUNCTION  <lambda>53()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            return {'bufnr': bufnr('%'), 'curpos': getcurpos()[0:2], 'changedtick': b:changedtick }

FUNCTION  <lambda>54()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                            return a['bufnr'] == b['bufnr'] && a['curpos'] == b['curpos'] && a['changedtick'] == b['changedtick']

FUNCTION  <lambda>55()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return mode() is# 'n' && getbufvar(bufnr('%'), '&buftype') !=# 'terminal'

FUNCTION  <lambda>56()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 1 time
Total time:   0.000422
 Self time:   0.000037

count  total (s)   self (s)
                            return lsp#callbag#pipe(       s:send_request(),       lsp#callbag#materialize(),       lsp#callbag#filter({x->lsp#callbag#isNextNotification(x)}),       lsp#callbag#map({x->x['value']}),       lsp#callbag#takeUntil(           lsp#callbag#fromEvent('BufLeave')       )   ) 

FUNCTION  <lambda>58()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/show_message_request.vim:3
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            return g:lsp_show_message_request_enabled &&   has_key(x, 'request') && !has_key(x, 'response') &&   has_key(x['request'], 'method') && x['request']['method'] ==# 'window/showMessageRequest'

FUNCTION  matchup#pos#get_cursor()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/pos.vim:17
Called 5 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    5              0.000017     return getcurpos()

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:65
Called 75 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   75              0.000156   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   75              0.000036   endif
   75              0.000176   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>174_notify_event_handler()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:520
Called 3 times
Total time:   0.000286
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000013     let l:data = s:event_handlers_data[a:index]
    3   0.000272   0.000019     call l:data['handler']()

FUNCTION  lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:83
Called 50 times
Total time:   0.000388
 Self time:   0.000314

count  total (s)   self (s)
   50   0.000373   0.000299     return get(s:diagnostics_state, lsp#utils#normalize_uri(a:uri), {})

FUNCTION  <SNR>174_materializeFSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1411
Called 5 times
Total time:   0.002675
 Self time:   0.000122

count  total (s)   self (s)
    5              0.000006     if a:t == 1
    1   0.000301   0.000012         call a:data['sink'](1, lsp#callbag#createNextNotification(a:d))
    4              0.000005     elseif a:t == 2
    2   0.000116   0.000030         call a:data['sink'](1, lsp#callbag#isUndefined(a:d) ? lsp#callbag#createCompleteNotification() : lsp#callbag#createErrorNotification(a:d))
    2   0.000700   0.000013         call a:data['sink'](2, lsp#callbag#undefined())
    2              0.000002     else
    2   0.001499   0.000008         call a:data['sink'](a:t, a:d)
    5              0.000003     endif

FUNCTION  <SNR>173_send_request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:854
Called 1 time
Total time:   0.000195
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003     let l:lsp_id = s:servers[a:server_name]['lsp_id']
    1              0.000002     let l:data = copy(a:data)
    1              0.000002     if has_key(l:data, 'on_notification')
    1              0.000002         let l:data['on_notification'] = '---funcref---'
    1              0.000000     endif
    1   0.000009   0.000004     call lsp#log_verbose('--->', l:lsp_id, a:server_name, l:data)
    1   0.000176   0.000008     return lsp#client#send_request(l:lsp_id, a:data)

FUNCTION  <lambda>61()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/show_message.vim:8
Called 4 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                            return g:lsp_show_message_log_level !=# 'none' &&   has_key(x, 'response') && has_key(x['response'], 'method')   && x['response']['method'] ==# 'window/showMessage'

FUNCTION  <SNR>106_on_text_changed()
    Defined: ~/.vim/plugged/vim-vsnip/plugin/vsnip.vim:212
Called 1 time
Total time:   0.000022
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000016   0.000011   let l:session = vsnip#get_session()
    1              0.000003   if !empty(l:session)
                                call l:session.on_text_changed()
    1              0.000001   endif

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:520
Called 15 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
   15              0.000023   return s:loaded_ext

FUNCTION  lsp#callbag#filter()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:431
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000006     let l:data = { 'condition': a:condition }
    2              0.000007     return function('s:filterCondition', [l:data])

FUNCTION  <SNR>229_has_provider()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/capabilities.vim:1
Called 3 times
Total time:   0.000097
 Self time:   0.000072

count  total (s)   self (s)
    3   0.000044   0.000019     let l:value = lsp#get_server_capabilities(a:server_name)
    4              0.000008     for l:provider in a:000
    3              0.000019         if empty(l:value) || type(l:value) != type({}) || !has_key(l:value, l:provider)
    2              0.000002             return 0
    1              0.000001         endif
    1              0.000003         let l:value = l:value[l:provider]
    2              0.000001     endfor
    1              0.000006     return (type(l:value) == type(v:true) && l:value == v:true) || type(l:value) == type({})

FUNCTION  <SNR>216_callback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/step.vim:13
Called 6 times
Total time:   0.004625
 Self time:   0.000004

count  total (s)   self (s)
    6   0.001153   0.000896     call s:next(a:steps, a:current_index + 1, a:000)

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:190
Called 15 times
Total time:   0.000270
 Self time:   0.000121

count  total (s)   self (s)
   15   0.000263   0.000114   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  <SNR>142_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 1452 times
Total time:   0.031125
 Self time:   0.031125

count  total (s)   self (s)
 1452              0.002041     let color = ''
 1452              0.004486     if hlexists(a:group)
 1396              0.007296       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 1452              0.000883     endif
 1452              0.003181     if empty(color) || color == -1
                                  " should always exist
   56              0.000339       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
   56              0.000115       if empty(color) || color == -1
                                    let color = 'NONE'
   56              0.000027       endif
 1452              0.000717     endif
 1452              0.001460     return color

FUNCTION  lsp#callbag#empty()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:183
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001     let l:data = {}
    1              0.000005     return function('s:emptyStart', [l:data])

FUNCTION  lsp#callbag#undefined()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:7
Called 42 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   42              0.000064     return s:undefined_token

FUNCTION  <SNR>69_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:87
Called 1 time
Total time:   0.000029
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000009   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    1              0.000001   endif
    1   0.000015   0.000009   call airline#update_tabline()

FUNCTION  lsp#client#send_request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:294
Called 1 time
Total time:   0.000168
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000168   0.000006     return s:lsp_send(a:client_id, a:opts, s:send_type_request)

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:51
Called 105 times
Total time:   0.000958
 Self time:   0.000958

count  total (s)   self (s)
  105              0.000229   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  105              0.000056   endif
  105              0.000271   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  105              0.000277   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  lsp#client#send_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:298
Called 1 time
Total time:   0.000172
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000171   0.000006     return s:lsp_send(a:client_id, a:opts, s:send_type_notification)

FUNCTION  <SNR>174_takeUntilSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1023
Called 5 times
Total time:   0.002321
 Self time:   0.000170

count  total (s)   self (s)
    5              0.000007     if a:t == 0
    2              0.000005         let a:data['sourceTalkback'] = a:d
    2   0.001261   0.000025         call a:data['notifier'](0, function('s:takeUntilNotifierCallback', [a:data]))
    2              0.000005         let a:data['inited'] = 1
    2   0.000144   0.000024         call a:data['sink'](0, function('s:takeUntilSinkCallback', [a:data]))
    2              0.000010         if a:data['done'] != s:takeUntilUniqueToken | call a:data['sink'](2, a:data['done']) | endif
    2              0.000000         return
    3              0.000000     endif
    3              0.000003     if a:t == 2
    2   0.000546   0.000015         call a:data['notifierTalkback'](2, lsp#callbag#undefined())
    3              0.000001     endif
    3              0.000007     if a:data['done'] == s:takeUntilUniqueToken
    3   0.000285   0.000021         call a:data['sink'](a:t, a:d)
    3              0.000001     endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 126 times
Total time:   0.019218
 Self time:   0.000957

count  total (s)   self (s)
  126   0.019183   0.000922     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>175_on_text_changed_after()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/signature_help.vim:123
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000025     if bufnr('%') != a:bufnr
                                    return
    1              0.000001     endif
    1              0.000014     if index(['i', 's'], mode()[0]) == -1
    1              0.000002         return
                                endif
                                if win_id2win(lsp#ui#vim#output#getpreviewwinid()) >= 1
                                    return
                                endif
                            
                                " Cache trigger chars since this loop is heavy
                                let l:chars = get(b:, 'lsp_signature_help_trigger_character', [])
                                if empty(l:chars)
                                    for l:server_name in lsp#get_allowed_servers(a:bufnr)
                                        let l:chars += lsp#capabilities#get_signature_help_trigger_characters(l:server_name)
                                    endfor
                                    let b:lsp_signature_help_trigger_character = l:chars
                                endif
                            
                                if index(l:chars, lsp#utils#_get_before_char_skip_white()) >= 0
                                    call lsp#ui#vim#signature_help#get_signature_help_under_cursor()
                                endif

FUNCTION  <lambda>18()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                            return {'bufnr': bufnr('%'), 'curpos': getcurpos()[0:2], 'changedtick': b:changedtick }

FUNCTION  matchup#perf#timeout()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/perf.vim:79
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return float2nr(s:timeout)

FUNCTION  <SNR>145_config_fugitive_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 15 times
Total time:   0.002880
 Self time:   0.000242

count  total (s)   self (s)
   15   0.002586   0.000101   let s:vcs_config['git'].branch =  FugitiveHead(s:sha1size)
   15   0.000253   0.000100   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   15              0.000005   endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 9 times
Total time:   0.102401
 Self time:   0.015716

count  total (s)   self (s)
    9              0.000023     let bufnr = a:0 ? a:1 : ''
    9              0.000023     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    9              0.000076     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    9              0.000026     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    9              0.000018     let airline_grouplist = []
    9              0.000045     let buffers_in_tabpage = sort(tabpagebuflist())
    9              0.000024     if exists("*uniq")
    9              0.000026       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    9              0.000008     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   22              0.000040     for mode in reverse(mapped)
   13              0.000066       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    7              0.000023         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  123              0.000222         for kvp in items(dict)
  116              0.000274           let mode_colors = kvp[1]
  116              0.000240           let name = kvp[0]
  116              0.000338           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
  116              0.000070           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
  116              0.000556           if name =~# 'airline_c\d\+'
   14              0.000096             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   14              0.000050             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                          continue
   14              0.000006             endif
  102              0.000542           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   49              0.000040             continue
   67              0.000029           endif
   67   0.001021   0.000436           if s:group_not_done(airline_grouplist, name.suffix)
   55   0.016318   0.000359             call airline#highlighter#exec(name.suffix, mode_colors)
   67              0.000044           endif
                            
   67              0.000165           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   67              0.000039           endif
                            
  201              0.000345           for accent in keys(s:accents)
  134              0.000339             if !has_key(p.accents, accent)
                                          continue
  134              0.000069             endif
  134              0.000370             let colors = copy(mode_colors)
  134              0.000385             if p.accents[accent][0] != ''
   67              0.000271               let colors[0] = p.accents[accent][0]
  134              0.000094             endif
  134              0.000311             if p.accents[accent][2] != ''
   67              0.000196               let colors[2] = p.accents[accent][2]
  134              0.000083             endif
  134              0.000272             if len(colors) >= 5
  134              0.000512               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
  134              0.000089             endif
  134   0.002139   0.000998             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  110   0.031644   0.000790               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  134              0.000077             endif
  201              0.000135           endfor
   74              0.000036         endfor
                            
    7              0.000017         if empty(s:separators)
                                      " nothing to be done
                                      continue
    7              0.000003         endif
                                    " TODO: optimize this
   70              0.000123         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   63   0.038808   0.000662           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   70              0.000050         endfor
   13              0.000008       endif
   22              0.000021     endfor

FUNCTION  <SNR>147_airline_lsp_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:11
Called 30 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
   30              0.000056   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  lsp#log()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:45
Called 8 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    8              0.000016     if !empty(g:lsp_log_file)
                                    call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
    8              0.000004     endif

FUNCTION  lsp#callbag#pipe()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:29
Called 2 times
Total time:   0.000216
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000006     let l:Res = a:1
    2              0.000002     let l:i = 1
   10              0.000017     while l:i < a:0
    8   0.000151   0.000061         let l:Res = a:000[l:i](l:Res)
    8              0.000018         let l:i = l:i + 1
   10              0.000008     endwhile
    2              0.000002     return l:Res

FUNCTION  <SNR>174_shareTalkbackCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1355
Called 25 times
Total time:   0.000840
 Self time:   0.000549

count  total (s)   self (s)
   25              0.000026     if a:t == 2
                                    let l:i = 0
                                    let l:found = 0
                                    while l:i < len(a:data['sinks'])
                                        if a:data['sinks'][l:i] == a:sink
                                            let l:found = 1
                                            break
                                        endif
                                        let l:i += 1
                                    endwhile
                            
                                    if l:found
                                        call remove(a:data['sinks'], l:i)
                                    endif
                            
                                    if empty(a:data['sinks'])
                                        call a:data['sourceTalkback'](2, lsp#callbag#undefined())
                                    endif
   25              0.000014     else
   25   0.000415   0.000124         call a:data['sourceTalkback'](a:t, a:d)
   25              0.000010     endif

FUNCTION  <SNR>174_debounceTimeSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:577
Called 5 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    5              0.000026     if has_key(a:data, 'timer') | call timer_stop(a:data['timer']) | endif
    5              0.000005     if a:t == 1
    5              0.000037         let a:data['timer'] = timer_start(a:data['duration'], function('s:debounceTimeTimerCallback', [a:data, a:d]))
                                else
                                    call a:data['sink'](a:t, a:d)
    5              0.000001     endif

FUNCTION  <SNR>173_ensure_flush()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:427
Called 1 time
Total time:   0.001332
 Self time:   0.000039

count  total (s)   self (s)
    1   0.001330   0.000037     call lsp#utils#step#start([ {s->s:ensure_start(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_init(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_conf(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_open(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_changed(a:buf, a:server_name, s.callback)}, {s->a:cb(s.result[0])} ])

FUNCTION  <SNR>193_clear_all_signs()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:96
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     call sign_unplace(s:sign_group)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 134 times
Total time:   0.001321
 Self time:   0.001321

count  total (s)   self (s)
  134              0.000351   let nr = get(a:000, 0, 0)
                              " When statusline is on top, or using global statusline for Neovim
                              " always return the number of columns
  134              0.000382   if get(g:, 'airline_statusline_ontop', 0) || &laststatus > 2
                                return &columns
  134              0.000072   else
  134              0.000232     return winwidth(nr)
                              endif

FUNCTION  <SNR>174_switchMapCurrSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1322
Called 5 times
Total time:   0.000384
 Self time:   0.000140

count  total (s)   self (s)
    5              0.000017     if a:currT == 0 | let a:data['currSourceTalkback'] = a:currD | endif
    5   0.000196   0.000027     if a:currT == 1 | call a:data['outputSink'](a:t, a:data['combineResults'](a:d, a:currD)) | endif
    5              0.000014     if (a:currT == 0 || a:currT == 1) && has_key(a:data, 'currSourceTalkback')
    3   0.000112   0.000037         call a:data['currSourceTalkback'](1, lsp#callbag#undefined())
    5              0.000004     endif
    5              0.000005     if a:currT == 2
    2              0.000004         call remove(a:data, 'currSourceTalkback')
    2              0.000008         if a:data['sourceEnded'] | call a:data['outputSink'](a:currT, a:currD) | endif
    5              0.000001     endif

FUNCTION  matchup#delim#set_invert_skip()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/delim.vim:918
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   let s:invert_skip = a:val

FUNCTION  <SNR>173_ensure_changed()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:754
Called 1 time
Total time:   0.000791
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000002     let l:server = s:servers[a:server_name]
    1   0.000026   0.000005     let l:path = lsp#utils#get_buffer_uri(a:buf)
                            
    1              0.000002     let l:buffers = l:server['buffers']
    1              0.000002     if !has_key(l:buffers, l:path)
                                    let l:msg = s:new_rpc_success('file is not managed', { 'server_name': a:server_name, 'path': l:path })
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                    return
    1              0.000000     endif
    1              0.000002     let l:buffer_info = l:buffers[l:path]
                            
    1              0.000003     let l:changed_tick = getbufvar(a:buf, 'changedtick')
                            
    1              0.000002     if l:buffer_info['changed_tick'] == l:changed_tick
                                    let l:msg = s:new_rpc_success('not dirty', { 'server_name': a:server_name, 'path': l:path })
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                    return
    1              0.000000     endif
                            
    1              0.000002     let l:buffer_info['changed_tick'] = l:changed_tick
    1              0.000003     let l:buffer_info['version'] = l:buffer_info['version'] + 1
                            
    1   0.000378   0.000021     call s:send_notification(a:server_name, { 'method': 'textDocument/didChange', 'params': {   'textDocument': s:get_versioned_text_document_identifier(a:buf, l:buffer_info),   'contentChanges': s:text_changes(a:buf, a:server_name), } })
    1   0.000042   0.000007     call lsp#ui#vim#folding#send_request(a:server_name, a:buf, 0)
                            
    1   0.000013   0.000007     let l:msg = s:new_rpc_success('textDocument/didChange sent', { 'server_name': a:server_name, 'path': l:path })
    1   0.000010   0.000004     call lsp#log(l:msg)
    1   0.000289   0.000002     call a:cb(l:msg)

FUNCTION  <SNR>177_clear_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:132
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000002     if s:use_vim_textprops
    1              0.000002         if exists('b:lsp_reference_matches')
                                        let l:bufnr = bufnr('%')
                                        for l:line in b:lsp_reference_matches
                                            silent! call prop_remove(   {'id': s:prop_id,    'bufnr': l:bufnr,    'all': v:true}, l:line)
                                        endfor
                                        unlet b:lsp_reference_matches
                                        unlet b:lsp_reference_positions
    1              0.000000         endif
                                else
                                    if exists('w:lsp_reference_matches')
                                        for l:match in w:lsp_reference_matches
                                            silent! call matchdelete(l:match)
                                        endfor
                                        unlet w:lsp_reference_matches
                                        unlet w:lsp_reference_positions
                                    endif
    1              0.000000     endif

FUNCTION  55()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 4 times
Total time:   0.000384
 Self time:   0.000195

count  total (s)   self (s)
    4              0.000013     let options = a:0 ? a:1 : {}
    4              0.000004     let toReturn = ''
                            
    4              0.000009     if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    4              0.000003     else
    4   0.000192   0.000018         let toReturn = self._str()
    4              0.000002     endif
                            
    4   0.000033   0.000018     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
    4              0.000001     endif
                            
    4              0.000007     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
    4              0.000002     endif
                            
    4              0.000004     return toReturn

FUNCTION  60()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 4 times
Total time:   0.000174
 Self time:   0.000073

count  total (s)   self (s)
    4   0.000101   0.000021     let l:separator = nerdtree#slash()
    4              0.000006     let l:leader = l:separator
                            
    4   0.000034   0.000013     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
    4              0.000001     endif
                            
    4              0.000017     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  <SNR>174_emptyStart()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:188
Called 1 time
Total time:   0.001114
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003     if a:start != 0 | return | endif
    1              0.000002     let a:data['disposed'] = 0
    1   0.000786   0.000010     call a:sink(0, function('s:emptySinkCallback', [a:data]))
    1              0.000002     if a:data['disposed'] | return | endif
    1   0.000320   0.000009     call a:sink(2, lsp#callbag#undefined())

FUNCTION  <SNR>142_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 201 times
Total time:   0.001726
 Self time:   0.001726

count  total (s)   self (s)
  201              0.000649     if index(a:list, a:name) == -1
  165              0.000425       call add(a:list, a:name)
  165              0.000169       return 1
   36              0.000025     else
   36              0.000075       if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
   36              0.000025       endif
   36              0.000038       return 0
                                endif

FUNCTION  <SNR>174_fromEventHandlerCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:504
Called 3 times
Total time:   0.000253
 Self time:   0.000033

count  total (s)   self (s)
                                " send v:event if it exists
    3   0.000252   0.000032     call a:data['sink'](1, lsp#callbag#undefined())

FUNCTION  lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:156
Called 30 times
Total time:   0.002723
 Self time:   0.001501

count  total (s)   self (s)
   30              0.000125     let l:counts = { 'error': 0, 'warning': 0, 'information': 0, 'hint': 0, }
   30   0.000310   0.000201     if lsp#internal#diagnostics#state#_is_enabled_for_buffer(a:bufnr)
   30   0.000943   0.000168         let l:uri = lsp#utils#get_buffer_uri(a:bufnr)
   60   0.000617   0.000381         for [l:_, l:response] in items(lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri))
   30   0.000283   0.000181             for l:diagnostic in lsp#utils#iteratable(l:response['params']['diagnostics'])
                                            let l:key = get(s:diagnostic_kinds, get(l:diagnostic, 'severity', 1) , 'error')
                                            let l:counts[l:key] += 1
   30              0.000022             endfor
   60              0.000034         endfor
   30              0.000013     end
   30              0.000033     return l:counts

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 363 times
Total time:   0.055176
 Self time:   0.022071

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  363              0.002088     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  363              0.001308     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  363              0.000241     else
  363   0.010227   0.002053       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  363   0.009935   0.002104       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  363   0.009506   0.001938       let guifg = s:get_syn(a:group, 'fg', 'gui')
  363   0.009482   0.001930       let guibg = s:get_syn(a:group, 'bg', 'gui')
  363              0.001704       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  363              0.000393       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  363              0.000240       else
  363   0.004465   0.002485         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  363              0.000233       endif
  363              0.000166     endif
  363              0.001118     let s:hl_groups[a:group] = res
  363              0.000382     return res

FUNCTION  <SNR>173_on_text_document_did_change()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:307
Called 1 time
Total time:   0.000078
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000003     let l:buf = bufnr('%')
    1              0.000006     if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    1   0.000015   0.000007     call lsp#log('s:on_text_document_did_change()', l:buf)
    1   0.000053   0.000007     call s:add_didchange_queue(l:buf)

FUNCTION  <SNR>173_text_changes()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:728
Called 1 time
Total time:   0.000130
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000038   0.000007     let l:sync_kind = lsp#capabilities#get_text_document_change_sync_kind(a:server_name)
                                " When syncKind is None, return null for contentChanges.
    1              0.000001     if l:sync_kind == 0
                                    return v:null
    1              0.000001     endif
                            
                                " When syncKind is Incremental and previous content is saved.
    1              0.000003     if l:sync_kind == 2 && has_key(s:file_content, a:buf)
                                    " compute diff
                                    let l:old_content = s:get_last_file_content(a:buf, a:server_name)
                                    let l:new_content = lsp#utils#buffer#_get_lines(a:buf)
                                    let l:changes = lsp#utils#diff#compute(l:old_content, l:new_content)
                                    if empty(l:changes.text) && l:changes.rangeLength ==# 0
                                        return []
                                    endif
                                    call s:update_file_content(a:buf, a:server_name, l:new_content)
                                    return [l:changes]
    1              0.000001     endif
                            
    1   0.000036   0.000005     let l:new_content = lsp#utils#buffer#_get_lines(a:buf)
    1              0.000006     let l:changes = {'text': join(l:new_content, "\n")}
    1   0.000029   0.000007     call s:update_file_content(a:buf, a:server_name, l:new_content)
    1              0.000001     return [l:changes]

FUNCTION  <SNR>174_makeSubjectFactory()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:64
Called 4 times
Total time:   0.004890
 Self time:   0.001172

count  total (s)   self (s)
    4              0.000005     if a:t == 0
                                    let l:Sink = a:d
                                    call add(a:data['sinks'], l:Sink)
                                    call l:Sink(0, function('s:makeSubjectSinkCallback', [a:data, l:Sink]))
    4              0.000001     else
    4              0.000018         let l:zinkz = copy(a:data['sinks'])
    4              0.000005         let l:i = 0
    4              0.000010         let l:n = len(l:zinkz)
   28              0.000031         while l:i < l:n
   24              0.000054             let l:Sink = l:zinkz[l:i]
   24              0.000027             let l:j = -1
   24              0.000028             let l:found = 0
   24              0.000049             for l:Item in a:data['sinks']
   24              0.000028                 let l:j += 1
   24              0.000951                 if l:Item == l:Sink
   24              0.000027                     let l:found = 1
   24              0.000016                     break
                                            endif
   24              0.000014             endfor
                            
   24              0.000018             if l:found
   24   0.002189   0.000237                 call l:Sink(a:t, a:d)
   24              0.000009             endif
   24              0.000024             let l:i += 1
   28              0.000019         endwhile
    4              0.000003     endif

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:44
Called 154 times
Total time:   0.001115
 Self time:   0.000834

count  total (s)   self (s)
  154   0.000714   0.000433   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
   15              0.000013     return ''
  139              0.000071   endif
  139              0.000134   return a:text

FUNCTION  lsp#internal#work_done_progress#get_progress()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/work_done_progress.vim:68
Called 15 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   15              0.000029     return s:progress_ui

FUNCTION  <SNR>174_fromEventSinkHandler()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:509
Called 9 times
Total time:   0.000543
 Self time:   0.000543

count  total (s)   self (s)
    9              0.000019     if a:t != 2 | return | endif
    2              0.000004     let a:data['disposed'] = 1
    2              0.000010     execute 'augroup ' a:data['augroup']
    2              0.000483     autocmd!
    2              0.000004     execute 'augroup end'
    2              0.000007     if has_key(s:event_handlers_data, a:data['handler_index'])
    2              0.000010         call remove(s:event_handlers_data, a:data['handler_index'])
    2              0.000002     endif

FUNCTION  lsp#callbag#map()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:409
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000005     let l:data = { 'f': a:F }
    2              0.000006     return function('s:mapF', [l:data])

FUNCTION  <SNR>180_echo()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/echo.vim:33
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if !empty(a:diagnostic) && has_key(a:diagnostic, 'message')
                                    call lsp#utils#echo_with_truncation('LSP: '. substitute(a:diagnostic['message'], '\n\+', ' ', 'g'))
                                    let s:displaying_message = 1
    1              0.000003     elseif get(s:, 'displaying_message', 0)
                                    call lsp#utils#echo_with_truncation('')
                                    let s:displaying_message = 0
    1              0.000001     endif

FUNCTION  lsp#request()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1111
Called 1 time
Total time:   0.000032
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000007     let l:ctx = { 'server_name': a:server_name, 'request': copy(a:request), 'request_id': 0, 'done': 0, 'cancelled': 0, }
    1   0.000024   0.000012     return lsp#callbag#create(function('s:request_create', [l:ctx]))

FUNCTION  <SNR>174_filterSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:447
Called 41 times
Total time:   0.010863
 Self time:   0.000765

count  total (s)   self (s)
   41              0.000045     if a:t == 0
    2              0.000004         let a:data['talkback'] = a:d
    2   0.001463   0.000010         call a:data['sink'](a:t, a:d)
   39              0.000043     elseif a:t == 1
   37   0.000364   0.000146         if a:data['condition'](a:d)
   14   0.002032   0.001595             call a:data['sink'](a:t, a:d)
   23              0.000014         else
   23   0.000917   0.000168             call a:data['talkback'](1, lsp#callbag#undefined())
   37              0.000017         endif
    2              0.000001     else
    2   0.000660   0.000008         call a:data['sink'](a:t, a:d)
   41              0.000015     endif

FUNCTION  <SNR>144_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 15 times
Total time:   0.000491
 Self time:   0.000122

count  total (s)   self (s)
   15   0.000438   0.000069   let hunks = GitGutterGetHunkSummary()
   15              0.000042   return hunks == [0, 0, 0] ? [] : hunks

FUNCTION  <SNR>174_mergeTalkbackCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:794
Called 4 times
Total time:   0.000323
 Self time:   0.000171

count  total (s)   self (s)
    4              0.000011     if a:t == 2 | let a:data['ended'] = 1 | endif
    4              0.000004     let l:i = 0
   12              0.000019     while l:i < a:data['n']
    8              0.000037         if l:i < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:i] != 0
    8   0.000200   0.000048             call a:data['sourceTalkbacks'][l:i](a:t, a:d)
    8              0.000004         endif
    8              0.000008         let l:i += 1
   12              0.000009     endwhile

FUNCTION  lsp#capabilities#has_folding_range_provider()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/capabilities.vim:104
Called 1 time
Total time:   0.000027
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000027   0.000006     return s:has_provider(a:server_name, 'foldingRangeProvider')

FUNCTION  <SNR>174_filterConditionSource()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:441
Called 2 times
Total time:   0.003377
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000006     if a:start != 0 | return | endif
    2              0.000004     let a:data['sink'] = a:sink
    2   0.003365   0.000015     call a:data['source'](0, function('s:filterSourceCallback', [a:data]))

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:202
Called 8 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    8              0.000048     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>193_place_signs()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:129
Called 1 time
Total time:   0.000042
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000012   0.000006     for l:item in lsp#utils#iteratable(a:diagnostics_response['params']['diagnostics'])
                                    let l:line = lsp#utils#position#lsp_line_to_vim(a:bufnr, l:item['range']['start'])
                            
                                    " Some language servers report an unexpected EOF one line past the end
                                    " key 'linecount' may be missing.
                                    if has_key(getbufinfo(a:bufnr)[0], 'linecount')
                                        if l:line == getbufinfo(a:bufnr)[0].linecount + 1
                                            let l:line = l:line - 1
                                        endif
                                    endif
                            
                                    if has_key(l:item, 'severity') && !empty(l:item['severity'])
                                        let l:sign_name = get(s:severity_sign_names_mapping, l:item['severity'], 'LspError')
                                        let l:sign_priority = get(g:lsp_diagnostics_signs_priority_map, l:sign_name, g:lsp_diagnostics_signs_priority)
                                        let l:sign_priority = get(g:lsp_diagnostics_signs_priority_map, a:server . '_' . l:sign_name, l:sign_priority)
                                        " pass 0 and let vim generate sign id
                                        let l:sign_id = sign_place(0, s:sign_group, l:sign_name, a:bufnr,{ 'lnum': l:line, 'priority': l:sign_priority })
                                    endif
    1              0.000001     endfor

FUNCTION  lsp#get_buffer_diagnostics_counts()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1259
Called 30 times
Total time:   0.002998
 Self time:   0.000275

count  total (s)   self (s)
   30   0.002989   0.000266     return lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer(bufnr('%'))

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:236
Called 15 times
Total time:   0.002485
 Self time:   0.000471

count  total (s)   self (s)
   15              0.000100   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
   15              0.000021   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
   15              0.000011   else
   15   0.000603   0.000060     let dir = FugitiveGitDir()
   15              0.000044     let arg = get(a:, 1, 0)
   15              0.000008   endif
   15              0.000022   if empty(dir)
                                return ''
   15              0.000005   endif
   15   0.001547   0.000076   return fugitive#Head(arg, dir)

FUNCTION  lsp#get_text_document_identifier()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1063
Called 1 time
Total time:   0.000059
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000005     let l:buf = a:0 > 0 ? a:1 : bufnr('%')
    1   0.000054   0.000010     return { 'uri': lsp#utils#get_buffer_uri(l:buf) }

FUNCTION  <SNR>173_ensure_conf()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:711
Called 1 time
Total time:   0.001017
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000002     let l:server = s:servers[a:server_name]
    1              0.000002     let l:server_info = l:server['server_info']
    1              0.000005     if has_key(l:server_info, 'workspace_config') && !get(l:server_info, '_workspace_config_sent', v:false)
                                    let l:server_info['_workspace_config_sent'] = v:true
                                    call s:send_notification(a:server_name, { 'method': 'workspace/didChangeConfiguration', 'params': {   'settings': l:server_info['workspace_config'], } })
    1              0.000000     endif
    1   0.000011   0.000006     let l:msg = s:new_rpc_success('configuration sent', { 'server_name': a:server_name })
    1   0.000009   0.000004     call lsp#log(l:msg)
    1   0.000980   0.000002     call a:cb(l:msg)

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:196
Called 15 times
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
   15              0.000049   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   15              0.000029   let bomb     = &bomb ? '[BOM]' : ''
   15              0.000064   let noeolf   = &eol ? '' : '[!EOL]'
   15              0.000116   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   15              0.000071   if expected is# &fenc.bomb.noeolf.ff
                                return ''
   15              0.000010   else
   15              0.000053     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:138
Called 15 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
   15              0.000095   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   15              0.000179   return match(a:name, pat) > -1

FUNCTION  <SNR>173_ensure_start()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:438
Called 1 time
Total time:   0.001262
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000021   0.000008     let l:path = lsp#utils#get_buffer_path(a:buf)
                            
    1   0.000019   0.000006     if lsp#utils#is_remote_uri(l:path) || !has_key(s:servers, a:server_name)
                                    let l:msg = s:new_rpc_error('ignoring start server due to remote uri', { 'server_name': a:server_name, 'uri': l:path})
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                    return
    1              0.000000     endif
                            
    1              0.000003     let l:server = s:servers[a:server_name]
    1              0.000002     let l:server_info = l:server['server_info']
    1              0.000002     if l:server['lsp_id'] > 0
    1   0.000015   0.000009         let l:msg = s:new_rpc_success('server already started', { 'server_name': a:server_name })
    1   0.000011   0.000004         call lsp#log(l:msg)
    1   0.001180   0.000005         call a:cb(l:msg)
    1              0.000000         return
                                endif
                            
                                if has_key(l:server_info, 'tcp')
                                    let l:tcp = l:server_info['tcp'](l:server_info)
                                    let l:lsp_id = lsp#client#start({ 'tcp': l:tcp, 'on_stderr': function('s:on_stderr', [a:server_name]), 'on_exit': function('s:on_exit', [a:server_name]), 'on_notification': function('s:on_notification', [a:server_name]), 'on_request': function('s:on_request', [a:server_name]), })
                                elseif has_key(l:server_info, 'cmd')
                                    let l:cmd_type = type(l:server_info['cmd'])
                                    if l:cmd_type == v:t_list
                                        let l:cmd = l:server_info['cmd']
                                    else
                                        let l:cmd = l:server_info['cmd'](l:server_info)
                                    endif
                            
                                    if empty(l:cmd)
                                        let l:msg = s:new_rpc_error('ignore server start since cmd is empty', { 'server_name': a:server_name })
                                        call lsp#log(l:msg)
                                        call a:cb(l:msg)
                                        return
                                    endif
                            
                                    call lsp#log('Starting server', a:server_name, l:cmd)
                                    let l:opts = { 'cmd': l:cmd, 'on_stderr': function('s:on_stderr', [a:server_name]), 'on_exit': function('s:on_exit', [a:server_name]), 'on_notification': function('s:on_notification', [a:server_name]), 'on_request': function('s:on_request', [a:server_name]), }
                                    if has_key(l:server_info, 'env')
                                      let l:opts.env = l:server_info.env
                                    endif
                                    let l:lsp_id = lsp#client#start(l:opts)
                                endif
                            
                                if l:lsp_id > 0
                                    let l:server['lsp_id'] = l:lsp_id
                                    let l:msg = s:new_rpc_success('started lsp server successfully', { 'server_name': a:server_name, 'lsp_id': l:lsp_id })
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                else
                                    let l:msg = s:new_rpc_error('failed to start server', { 'server_name': a:server_name, 'cmd': l:cmd })
                                    call lsp#log(l:msg)
                                    call a:cb(l:msg)
                                endif

FUNCTION  <SNR>173_get_versioned_text_document_identifier()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1078
Called 1 time
Total time:   0.000031
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000030   0.000006     return { 'uri': lsp#utils#get_buffer_uri(a:buf), 'version': a:buffer_info['version'], }

FUNCTION  <SNR>174_createProd()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:120
Called 1 time
Total time:   0.002206
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000002     if a:start != 0 | return | endif
    1              0.000002     let a:data['sink'] = a:sink
    1              0.000008     if !has_key(a:data, 'prod') || type(a:data['prod']) != type(function('s:noop'))
                                    call a:sink(0, function('s:noop'))
                                    call a:sink(2, lsp#callbag#undefined())
                                    return
    1              0.000000     endif
    1              0.000002     let a:data['end'] = 0
    1   0.000766   0.000010     call a:sink(0, function('s:createSinkCallback', [a:data]))
    1              0.000002     if a:data['end'] | return | endif
    1   0.001416   0.000015     let a:data['clean'] = a:data['prod'](function('s:createNext', [a:data]), function('s:createError', [a:data]), function('s:createComplete', [a:data]))

FUNCTION  <SNR>204_get_delim_multi()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/delim.vim:43
Called 1 time
Total time:   0.000623
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000002   let l:best = {}
    2              0.000010   for l:e in get(get(b:, 'matchup_active_engines', {}), a:opts.type, [])
    1   0.000586   0.000017     let l:res = call(s:engines[l:e].get_delim, [a:opts])
    1              0.000003     if empty(l:res)
    1              0.000000       continue
                                endif
                                if a:opts.direction ==# 'current'
                                  return l:res
                                elseif a:opts.direction ==# 'next' && (empty(l:best) || matchup#pos#smaller(l:res, l:best))
                                  let l:best = l:res
                                elseif a:opts.direction ==# 'prev' && (empty(l:best) || matchup#pos#larger(l:res, l:best))
                                  let l:best = l:res
                                endif
    1              0.000001   endfor
    1              0.000001   return l:best

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:301
Called 20 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
   20              0.000123   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   20              0.000015   endif

FUNCTION  <SNR>204_get_delim()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/delim.vim:325
Called 1 time
Total time:   0.000569
 Self time:   0.000443

count  total (s)   self (s)
                              " arguments: {{{2
                              "   opts = {
                              "     'direction'   : 'next' | 'prev' | 'current'
                              "     'type'        : 'delim_tex'
                              "                   | 'delim_all'
                              "                   | 'all'
                              "     'side'        : 'open'     | 'close'
                              "                   | 'both'     | 'mid'
                              "                   | 'both_all' | 'open_mid'
                              "   }
                              "
                              "  }}}2
                              " returns: {{{2
                              "   delim = {
                              "     lnum     : line number
                              "     cnum     : column number
                              "     type     : e.g., 'delim_tex'
                              "     match    : the actual text match
                              "     side     : 'open' | 'close' | 'mid'
                              "     class    : [ c1, c2 ] identifies the kind of match_words
                              "     skip     : skip state
                              "     get_matching: callback used to get matching delims
                              "     highlighting: whether the request was for highlighting
                              "
                              "     ... Parser dependent ...
                              "     augment  : how to match a corresponding open
                              "     groups   : dict of captured groups
                              "     regexone : the regex items, like \1foo
                              "     regextwo : the regex_capture items, like \(group\)foo
                              "     midmap   : ??
                              "   }
                              "
                              " }}}2
                            
    1              0.000003   if !get(b:, 'matchup_delim_enabled', 0)
                                return {}
    1              0.000001   endif
                            
    1              0.000005   if has('*state') && state('a') !=# '' | return {} | endif
                            
    1   0.000016   0.000010   call matchup#perf#tic('s:get_delim')
                            
    1   0.000007   0.000004   let l:save_pos = matchup#pos#get_cursor()
                            
    1   0.000050   0.000009   call matchup#loader#refresh_match_words()
                            
                              " this contains all the patterns for the specified type and side
    1              0.000007   let l:re = b:matchup_delim_re[a:opts.type][a:opts.side]
                            
    1              0.000003   let l:cursorpos = col('.')
                            
    1              0.000003   let l:insertmode = get(a:opts, 'insertmode', 0)
    1              0.000002   if l:cursorpos > 1 && l:insertmode
                                let l:cursorpos -= 1
    1              0.000000   endif
    1              0.000006   if l:cursorpos > strlen(getline('.')) && stridx("vV\<c-v>", mode()) > -1
                                let l:cursorpos -= 1
    1              0.000000   endif
                            
    1   0.000010   0.000006   call matchup#delim#set_invert_skip(0)
                            
    1              0.000001   if a:opts.direction ==# 'current'
    1              0.000007     let l:check_skip = get(a:opts, 'check_skip', g:matchup_delim_noskips >= 2 || g:matchup_delim_noskips >= 1     && getline(line('.'))[l:cursorpos-1] =~? '[^[:punct:]]')
    1              0.000003     if l:check_skip && matchup#delim#skip(line('.'), l:cursorpos)
                                  return {}
    1              0.000001     endif
                              else
                                " check skip if cursor is not currently in skip
                                let l:check_skip = get(a:opts, 'check_skip', !matchup#delim#skip(line('.'), l:cursorpos) || g:matchup_delim_noskips >= 2)
    1              0.000000   endif
                            
    1              0.000002   let a:opts.cursorpos = l:cursorpos
                            
                              " for current, we want to find matches that end after the cursor
                              " note: we expect this to give false-positives with \ze
    1              0.000001   if a:opts.direction ==# 'current'
    1              0.000005     let l:re .= '\%>'.(l:cursorpos).'c'
    1              0.000001   endif
                            
                              " allow overlapping delimiters
                              " without this, the > in <tag> would not be found
    1              0.000003   if b:matchup_delim_re[a:opts.type]._engine_info.has_zs[a:opts.side]
                                let l:save_cpo = &cpo
                                noautocmd set cpo-=c
    1              0.000000   else
                                " faster than changing cpo but doesn't work right with \zs
    1              0.000002     let l:re .= '\&'
    1              0.000001   endif
                            
    1              0.000002   let l:need_restore_cursor = 0
                            
                              " stopline may depend on the current action
    1              0.000003   let l:stopline = get(a:opts, 'stopline', s:stopline)
                            
                              " in the first pass, we get matching line and column numbers
                              " this is intended to be as fast as possible, with no capture groups
                              " we look for a match on this line (if direction == current)
                              " or forwards or backwards (if direction == next or prev)
                              " for current, we actually search leftwards from the cursor
    1              0.000003   while 1
    1   0.000010   0.000007     let l:to = matchup#perf#timeout()
    1              0.000229     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + l:stopline, l:to) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW',               max([line('.') - l:stopline, 1]), l:to)   : searchpos(l:re, l:insertmode ? 'bnW' : 'bcnW',               line('.'), l:to)
    1              0.000004     if l:lnum == 0 | break | endif
                            
                                " note: the skip here should not be needed
                                " in 'current' mode, but be explicit
                                if a:opts.direction !=# 'current' && (l:check_skip || g:matchup_delim_noskips == 1     && getline(l:lnum)[l:cnum-1] =~? '[^[:punct:]]') && matchup#delim#skip(l:lnum, l:cnum) && (a:opts.direction ==# 'prev' ? (l:lnum > 1 || l:cnum > 1)     : (l:lnum < line('$') || l:cnum < len(getline('$'))))
                            
                                  " invalid match, move cursor and keep looking
                                  call matchup#pos#set_cursor(a:opts.direction ==# 'next' ? matchup#pos#next(l:lnum, l:cnum) : matchup#pos#prev(l:lnum, l:cnum))
                                  let l:need_restore_cursor = 1
                                  continue
                                endif
                            
                                break
    1              0.000001   endwhile
                            
                              " restore cpo if necessary
                              " note: this messes with cursor position
    1              0.000002   if exists('l:save_cpo')
                                noautocmd let &cpo = l:save_cpo
                                let l:need_restore_cursor = 1
    1              0.000001   endif
                            
                              " restore cursor
    1              0.000002   if l:need_restore_cursor
                                call matchup#pos#set_cursor(l:save_pos)
    1              0.000001   endif
                            
    1   0.000055   0.000010   call matchup#perf#toc('s:get_delim', 'first_pass')
                            
                              " nothing found, leave now
    1              0.000003   if l:lnum == 0
    1   0.000030   0.000006     call matchup#perf#toc('s:get_delim', 'nothing_found')
    1              0.000002     return {}
                              endif
                            
                              if matchup#perf#timeout_check()
                                return {}
                              endif
                            
                              let l:skip_state = 0
                              if !l:check_skip && (!&synmaxcol || l:cnum <= &synmaxcol)
                                " XXX: workaround an apparent obscure vim bug where the
                                " reported syntax id is incorrect on the first synID() call
                                call matchup#delim#skip(l:lnum, l:cnum)
                                if matchup#perf#timeout_check()
                                  return {}
                                endif
                            
                                let l:skip_state = matchup#delim#skip(l:lnum, l:cnum)
                              endif
                            
                              " now we get more data about the match in this position
                              " there may be capture groups which need to be stored
                            
                              " result stub, to be filled by the parser when there is a match
                              let l:result = { 'lnum'     : l:lnum, 'cnum'     : l:cnum, 'type'     : '', 'match'    : '', 'side'     : '', 'class'    : [], 'skip'     : l:skip_state,}
                            
                              for l:P in s:engines.classic.parsers[a:opts.type]
                                let l:parser_result = l:P(l:lnum, l:cnum, a:opts)
                                if !empty(l:parser_result)
                                  let l:result = extend(l:parser_result, l:result, 'keep')
                                  break
                                endif
                              endfor
                            
                              call matchup#perf#toc('s:get_delim', 'got_results')
                            
                              return empty(l:result.type) ? {} : l:result

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:177
Called 19 times
Total time:   0.000591
 Self time:   0.000303

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   19   0.000409   0.000121   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    4              0.000004     return ''
   15              0.000005   endif
   15              0.000074   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   15              0.000008   else
   15              0.000029     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>173_request_create()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1122
Called 1 time
Total time:   0.001401
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002     let a:ctx['next'] = a:next
    1              0.000001     let a:ctx['error'] = a:error
    1              0.000001     let a:ctx['complete'] = a:complete
    1              0.000004     let a:ctx['bufnr'] = get(a:ctx['request'], 'bufnr', bufnr('%'))
    1              0.000005     let a:ctx['request']['on_notification'] = function('s:request_on_notification', [a:ctx])
    1   0.001381   0.000016     call lsp#utils#step#start([ {s->s:ensure_flush(a:ctx['bufnr'], a:ctx['server_name'], s.callback)}, {s->s:is_step_error(s) ? s:request_error(a:ctx, s.result[0]) : s:request_send(a:ctx) }, ])
    1              0.000005     return function('s:request_cancel', [a:ctx])

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1016
Called 15 times
Total time:   0.001471
 Self time:   0.000764

count  total (s)   self (s)
   15              0.000050   let dir = a:0 > 1 ? a:2 : s:Dir()
   15              0.000018   if empty(dir)
                                return ''
   15              0.000009   endif
   15   0.000773   0.000066   let file = FugitiveActualDir() . '/HEAD'
   15              0.000121   let ftime = getftime(file)
   15              0.000019   if ftime == -1
                                return ''
   15              0.000066   elseif ftime != get(s:head_cache, file, [-1])[0]
                                let s:head_cache[file] = [ftime, readfile(file)[0]]
   15              0.000008   endif
   15              0.000040   let head = s:head_cache[file][1]
   15              0.000026   let len = a:0 ? a:1 : 0
   15              0.000049   if head =~# '^ref: '
   15              0.000018     if len < 0
                                  return strpart(head, 5)
   15              0.000009     else
   15              0.000138       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                endif
                              elseif head =~# '^\x\{40,\}$'
                                return len < 0 ? head : strpart(head, 0, len)
                              else
                                return ''
                              endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:170
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000013     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>173_request_on_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1146
Called 1 time
Total time:   0.000873
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003     if a:ctx['cancelled'] | return | endif " caller already unsubscribed so don't bother notifying
    1              0.000001     let a:ctx['done'] = 1
    1   0.000327   0.000007     call a:ctx['next'](extend({ 'server_name': a:ctx['server_name'] }, a:data))
    1   0.000540   0.000005     call a:ctx['complete']()

FUNCTION  <SNR>173_update_file_content()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:365
Called 1 time
Total time:   0.000022
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002     if !has_key(s:file_content, a:buf)
                                    let s:file_content[a:buf] = {}
    1              0.000000     endif
    1   0.000010   0.000004     call lsp#log('s:update_file_content()', a:buf)
    1              0.000007     let s:file_content[a:buf][a:server_name] = a:new

FUNCTION  lsp#get_allowed_servers()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:993
Called 2 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
    2              0.000004     if a:0 == 0
    2              0.000007         let l:buffer_filetype = &filetype
                                else
                                    if type(a:1) == type('')
                                        let l:buffer_filetype = a:1
                                    else
                                        let l:buffer_filetype = getbufvar(a:1, '&filetype')
                                    endif
    2              0.000001     endif
                            
                                " TODO: cache active servers per buffer
    2              0.000004     let l:active_servers = []
                            
    4              0.000014     for l:server_name in keys(s:servers)
    2              0.000008         let l:server_info = s:servers[l:server_name]['server_info']
    2              0.000002         let l:blocked = 0
                            
    2              0.000005         if has_key(l:server_info, 'blocklist')
    2              0.000004             let l:blocklistkey = 'blocklist'
                                    else
                                        let l:blocklistkey = 'blacklist'
    2              0.000002         endif
    2              0.000004         if has_key(l:server_info, l:blocklistkey)
    2              0.000006             for l:filetype in l:server_info[l:blocklistkey]
                                            if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
                                                let l:blocked = 1
                                                break
                                            endif
    2              0.000001             endfor
    2              0.000002         endif
                            
    2              0.000002         if l:blocked
                                        continue
    2              0.000003         endif
                            
    2              0.000004         if has_key(l:server_info, 'allowlist')
    2              0.000003             let l:allowlistkey = 'allowlist'
                                    else
                                        let l:allowlistkey = 'whitelist'
    2              0.000002         endif
    2              0.000004         if has_key(l:server_info, l:allowlistkey)
    2              0.000006             for l:filetype in l:server_info[l:allowlistkey]
    2              0.000004                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
    2              0.000006                     let l:active_servers += [l:server_name]
    2              0.000002                     break
                                            endif
    2              0.000002             endfor
    2              0.000001         endif
    4              0.000004     endfor
                            
    2              0.000003     return l:active_servers

FUNCTION  airline#extensions#lsp#progress()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:65
Called 15 times
Total time:   0.000335
 Self time:   0.000204

count  total (s)   self (s)
   15              0.000036   if get(w:, 'airline_active', 0)
   15              0.000039     if exists('*lsp#get_progress')
   15   0.000194   0.000063       let s:lsp_progress = lsp#get_progress()
                            
   15              0.000047       if len(s:lsp_progress) == 0 | return '' | endif
                            
                                  " show only most new progress
                                  let s:lsp_progress = s:lsp_progress[0]
                                  if s:lsp_progress['message'] !=# ''
                                    let percent = ''
                                    if has_key(s:lsp_progress, 'percentage') && s:lsp_progress['percentage'] >= 0
                                      let percent = ' ' . string(s:lsp_progress['percentage']) . '%'
                                    endif
                                    let s:title = s:lsp_progress['title']
                                    let message = airline#util#shorten(s:lsp_progress['message'] . percent, 91, 9)
                                    return s:lsp_progress['server'] . ': ' . s:title . ' ' . message
                                  endif
                                endif
                              endif
                              return ''

FUNCTION  <SNR>174_takeUntilNotifierCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1040
Called 2 times
Total time:   0.000047
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000002     if a:t == 0
    2              0.000005         let a:data['notifierTalkback'] = a:d
    2   0.000036   0.000023         call a:data['notifierTalkback'](1, lsp#callbag#undefined())
    2              0.000002         return
                                endif
                                if a:t == 1
                                    let a:data['done'] = 0
                                    call a:data['notifierTalkback'](2, lsp#callbag#undefined())
                                    call a:data['sourceTalkback'](2, lsp#callbag#undefined())
                                    if a:data['inited'] | call a:data['sink'](2, lsp#callbag#undefined()) | endif
                                    return
                                endif
                                if a:t ==2
                                    let a:data['notifierTalkback'] = 0
                                    let a:data['done'] = a:d
                                    if a:d != 0
                                        call a:data['sourceTalkback'](2, lsp#callbag#undefined())
                                        if a:data['inited'] | call a:data['sink'](a:t, a:d) | endif
                                    endif
                                endif

FUNCTION  292()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/matchparen.vim:135
Called 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000002   if exists('w:matchup_match_id_list')
                                for l:id in w:matchup_match_id_list
                                  silent! call matchdelete(l:id)
                                endfor
                                unlet! w:matchup_match_id_list
    1              0.000000   endif
    1              0.000004   if exists('s:ns_id')
                                call nvim_buf_clear_namespace(0, s:ns_id, 0, -1)
    1              0.000001   endif
                            
    1              0.000009   if !has('nvim') && exists('t:match_popup') && (exists('*win_gettype') ? win_gettype() !=# 'popup' : &buftype !=# 'terminal')
                                call s:do_popup_autocmd_leave(t:match_popup)
                                call popup_hide(t:match_popup)
    1              0.000003   elseif has('nvim')
                                call s:close_floating_win()
    1              0.000001   endif
                            
    1              0.000002   if exists('w:matchup_oldstatus')
                                let &l:statusline = w:matchup_oldstatus
                                unlet w:matchup_oldstatus
                                if exists('#User#MatchupOffscreenLeave')
                                  doautocmd <nomodeline> User MatchupOffscreenLeave
                                endif
    1              0.000000   endif
    1              0.000002   if exists('w:matchup_statusline')
                                unlet w:matchup_statusline
    1              0.000001   endif
                            
    1              0.000002   let w:matchup_need_clear = 0

FUNCTION  294()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/matchparen.vim:303
Called 2 times
Total time:   0.001295
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000011   if !get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
    2   0.001281   0.000019     return s:matchparen.highlight()
                              endif
                            
                              if !exists('w:matchup_timer')
                                let s:show_delay = g:matchup_matchparen_deferred_show_delay
                                let s:hide_delay = g:matchup_matchparen_deferred_hide_delay
                                let w:matchup_timer = timer_start(s:show_delay, function('s:timer_callback', [ win_getid() ]), {'repeat': -1})
                                if !exists('w:matchup_need_clear')
                                  let w:matchup_need_clear = 0
                                endif
                                let s:fade_time = g:matchup_matchparen_deferred_fade_time
                                if s:fade_time > 0
                                  let w:matchup_fade_timer = timer_start(s:fade_time, function('s:fade_timer_callback', [ win_getid() ]), {'repeat': -1})
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                              endif
                            
                              " keep the timer alive with a heartbeat
                              let w:matchup_pulse_time = reltime()
                            
                              " if the timer is paused, some time has passed
                              if timer_info(w:matchup_timer)[0].paused
                                " unpause the timer
                                call timer_pause(w:matchup_timer, 0)
                            
                                " set the hi time to the pulse time
                                let w:matchup_hi_time = w:matchup_pulse_time
                              endif

FUNCTION  airline#extensions#lsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:60
Called 15 times
Total time:   0.003962
 Self time:   0.000083

count  total (s)   self (s)
   15   0.003956   0.000077   return airline#extensions#lsp#get('error')

FUNCTION  <SNR>217_job_send()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/job.vim:229
Called 2 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000007     let l:jobinfo = s:jobs[a:jobid]
    2              0.000006     let l:close_stdin = get(a:opts, 'close_stdin', 0)
    2              0.000004     if l:jobinfo.type == s:job_type_nvimjob
                                    call jobsend(a:jobid, a:data)
                                    if l:close_stdin
                                      call chanclose(a:jobid, 'stdin')
                                    endif
    2              0.000004     elseif l:jobinfo.type == s:job_type_vimjob
                                    " There is no easy way to know when ch_sendraw() finishes writing data
                                    " on a non-blocking channels -- has('patch-8.1.889') -- and because of
                                    " this, we cannot safely call ch_close_in().  So when we find ourselves
                                    " in this situation (i.e. noblock=1 and close stdin after send) we fall
                                    " back to using s:flush_vim_sendraw() and wait for transmit buffer to be
                                    " empty
                                    "
                                    " Ref: https://groups.google.com/d/topic/vim_dev/UNNulkqb60k/discussion
    2              0.000016         if has('patch-8.1.818') && (!has('patch-8.1.889') || !l:close_stdin)
    2              0.000042             call ch_sendraw(l:jobinfo.channel, a:data)
                                    else
                                        let l:jobinfo.buffer .= a:data
                                        call s:flush_vim_sendraw(a:jobid, v:null)
    2              0.000002         endif
    2              0.000002         if l:close_stdin
                                        while len(l:jobinfo.buffer) != 0
                                            sleep 1m
                                        endwhile
                                        call ch_close_in(l:jobinfo.channel)
    2              0.000001         endif
    2              0.000001     endif

FUNCTION  <SNR>202_lsp_is_error()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:269
Called 9 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    9              0.000025     let l:vt = type(a:obj_or_response)
    9              0.000016     if l:vt == type('')
                                    return len(a:obj_or_response) > 0
    9              0.000019     elseif l:vt == type({})
    9              0.000018         return has_key(a:obj_or_response, 'error')
                                endif
                                return 0

FUNCTION  matchup#perf#timeout_start()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/perf.vim:84
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002   let s:timeout = a:timeout
    1              0.000003   let s:timeout_enabled = (a:timeout == 0) ? 0 : 1
    1              0.000007   let s:timeout_pulse_time = reltime()

FUNCTION  <lambda>52()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                            return g:lsp_document_code_action_signs_enabled

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 15 times
Total time:   0.000284
 Self time:   0.000123

count  total (s)   self (s)
   15   0.000280   0.000119   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>142_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 231 times
Total time:   0.002870
 Self time:   0.002870

count  total (s)   self (s)
  231              0.000758     if !hlexists(a:group)
                                  return 0
  231              0.001198     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  231              0.000132     endif
  231              0.000203     return 1

FUNCTION  lsp#callbag#materialize()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1395
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000004     let l:data = {}
    2              0.000007     return function('s:materializeF', [l:data])

FUNCTION  matchup#perf#toc()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/perf.vim:19
Called 3 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    3              0.000016   let l:elapsed = s:Reltimefloat(reltime(s:time_start[a:context]))
                            
    3              0.000007   let l:key = a:context.'#'.a:state
    3              0.000008   if has_key(g:matchup#perf#times, l:key)
    3              0.000008     if l:elapsed > g:matchup#perf#times[l:key].maximum
                                  let g:matchup#perf#times[l:key].maximum = l:elapsed
    3              0.000001     endif
    3              0.000010     let g:matchup#perf#times[l:key].last = l:elapsed
    3              0.000013     let g:matchup#perf#times[l:key].emavg = s:alpha*l:elapsed + (1-s:alpha)*g:matchup#perf#times[l:key].emavg
                              else
                                let g:matchup#perf#times[l:key] = { 'maximum' : l:elapsed, 'emavg'   : l:elapsed, 'last'    : l:elapsed,}
    3              0.000004   endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 15 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
   15              0.000071   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  lsp#internal#diagnostics#first_line#get_first_error_line()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/first_line.vim:6
Called 15 times
Total time:   0.001501
 Self time:   0.000951

count  total (s)   self (s)
   15              0.000077     let l:bufnr = get(a:options, 'bufnr', bufnr('%'))
                            
   15   0.000150   0.000100     if !lsp#internal#diagnostics#state#_is_enabled_for_buffer(l:bufnr)
                                    return v:null
   15              0.000006     endif
                            
   15   0.000419   0.000072     let l:uri = lsp#utils#get_buffer_uri(l:bufnr)
   15   0.000262   0.000153     let l:diagnostics_by_server = lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri)
                            
   15              0.000031     let l:first_error_line = v:null
   30              0.000068     for l:diagnostics_response in values(l:diagnostics_by_server)
   15   0.000125   0.000081         for l:item in lsp#utils#iteratable(l:diagnostics_response['params']['diagnostics'])
                                        let l:severity = get(l:item, 'severity', 1)
                                        if l:severity ==# 1 && (l:first_error_line ==# v:null || l:first_error_line ># l:item['range']['start']['line'])
                                            let l:first_error_line = l:item['range']['start']['line']
                                        endif
   15              0.000006         endfor
   30              0.000019     endfor
   15              0.000040     return l:first_error_line ==# v:null ? v:null : l:first_error_line + 1

FUNCTION  <SNR>145_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:202
Called 15 times
Total time:   0.001190
 Self time:   0.001006

count  total (s)   self (s)
   15              0.000105   let file = expand("%:p")
   15              0.000077   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   15              0.000004   endif
                            
   15              0.000023   let needs_update = 1
   15              0.000063   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
   45              0.000075   for vcs in keys(s:vcs_config)
   30              0.000112     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
   30              0.000015     endif
   30              0.000084     if has_key(s:vcs_config[vcs].untracked, file)
   15              0.000021       let needs_update = 0
   15   0.000289   0.000105       call airline#extensions#branch#update_untracked_config(file, vcs)
   30              0.000017     endif
   45              0.000026   endfor
                            
   15              0.000016   if !needs_update
   15              0.000012     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  lsp#callbag#createNextNotification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1426
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return { 'kind': 'N', 'value': a:d }

FUNCTION  vsnip#get_session()
    Defined: ~/.vim/plugged/vim-vsnip/autoload/vsnip.vim:109
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return s:session

FUNCTION  <SNR>145_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 15 times
Total time:   0.003367
 Self time:   0.000309

count  total (s)   self (s)
   15   0.000157   0.000069   call airline#util#ignore_next_focusgain()
   15   0.000147   0.000057   if airline#util#has_fugitive()
   15   0.002954   0.000074     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
   15              0.000010   endif

FUNCTION  lsp#utils#is_remote_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:46
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000011     return a:uri =~# '^\w\+::' || a:uri =~# '^[a-z][a-z0-9+.-]*://'

FUNCTION  <SNR>174_mapFSource()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:419
Called 2 times
Total time:   0.003405
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000006     if a:start != 0 | return | endif
    2              0.000004     let a:data['sink'] = a:sink
    2   0.003394   0.000017     call a:data['source'](0, function('s:mapFSourceCallback', [a:data]))

FUNCTION  <SNR>142_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 63 times
Total time:   0.038146
 Self time:   0.002388

count  total (s)   self (s)
   63              0.000105     if pumvisible()
                                  return
   63              0.000032     endif
   63              0.000172     let group = a:from.'_to_'.a:to.a:suffix
   63   0.009987   0.000367     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   63   0.010013   0.000415     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   63              0.000077     if a:inverse
   21              0.000095       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   42              0.000024     else
   42              0.000198       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   63              0.000042     endif
   63              0.000172     let a:dict[group] = colors
   63   0.016942   0.000402     call airline#highlighter#exec(group, colors)

FUNCTION  <lambda>115()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:20
Called 2 times
Total time:   0.000012
 Self time:   0.000008

count  total (s)   self (s)
                            return lsp#callbag#isNextNotification(x)

FUNCTION  <lambda>116()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:20
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x['value']

FUNCTION  lsp#capabilities#has_document_highlight_provider()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/capabilities.vim:100
Called 1 time
Total time:   0.000064
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000064   0.000011     return s:has_provider(a:server_name, 'documentHighlightProvider')

FUNCTION  <lambda>125()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:29
Called 1 time
Total time:   0.000007
 Self time:   0.000004

count  total (s)   self (s)
                            return lsp#callbag#isNextNotification(x)

FUNCTION  <SNR>181_place_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:130
Called 1 time
Total time:   0.000059
 Self time:   0.000056

count  total (s)   self (s)
                                " TODO: make diagnostics highlights same across vim and neovim
    1   0.000009   0.000006     for l:item in lsp#utils#iteratable(a:diagnostics_response['params']['diagnostics'])
                                    let [l:start_line, l:start_col] = lsp#utils#position#lsp_to_vim(a:bufnr, l:item['range']['start'])
                                    let [l:end_line, l:end_col] = lsp#utils#position#lsp_to_vim(a:bufnr, l:item['range']['end'])
                                    let l:severity = get(l:item, 'severity', 3)
                                    let l:hl_group = get(s:severity_sign_names_mapping, l:severity, 'LspError') . 'Highlight'
                                    if has('nvim')
                                        for l:line in range(l:start_line, l:end_line)
                                            if l:line == l:start_line
                                                let l:highlight_start_col = l:start_col
                                            else
                                                let l:highlight_start_col = 1
                                            endif
                            
                                            if l:line == l:end_line
                                                let l:highlight_end_col = l:end_col
                                            else
                                                " neovim treats -1 as end of line, special handle it later
                                                " when calling nvim_buf_add_higlight
                                                let l:highlight_end_col = -1
                                            endif
                            
                                            if l:start_line == l:end_line && l:highlight_start_col == l:highlight_end_col
                                                " higlighting same start col and end col on same line
                                                " doesn't work so use -1 for start col
                                                let l:highlight_start_col -= 1
                                                if l:highlight_start_col <= 0
                                                    let l:highlight_start_col = 1
                                                endif
                                            endif
                            
                                            call nvim_buf_add_highlight(a:bufnr, s:namespace_id, l:hl_group, l:line - 1, l:highlight_start_col - 1, l:highlight_end_col == -1 ? -1 : l:highlight_end_col)
                                        endfor
                                    else
                                        try
                                            " TODO: need to check for valid range before calling prop_add
                                            " See https://github.com/prabirshrestha/vim-lsp/pull/721
                                            silent! call prop_add(l:start_line, l:start_col, { 'end_lnum': l:end_line, 'end_col': l:end_col, 'bufnr': a:bufnr, 'type': s:get_prop_type_name(l:severity), })
                                        catch
                                            call lsp#log('diagnostics', 'place_highlights', 'prop_add', v:exception, v:throwpoint)
                                        endtry
                                    endif
    1              0.000001     endfor

FUNCTION  <SNR>174_shareSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:1379
Called 24 times
Total time:   0.003330
 Self time:   0.000408

count  total (s)   self (s)
   24              0.000029     if a:t == 0
                                    let a:data['sourceTalkback'] = a:d
                                    call a:sink(0, a:data['talkback'])
   24              0.000014     else
   48              0.000075         for l:S in a:data['sinks']
   24   0.001785   0.000241             call l:S(a:t, a:d)
   48              0.000019         endfor
   24              0.000014     endif
   24              0.000018     if a:t == 2
                                    let a:data['sinks'] = []
   24              0.000008     endif

FUNCTION  <SNR>173_on_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:902
Called 3 times
Total time:   0.004085
 Self time:   0.000130

count  total (s)   self (s)
    3   0.000030   0.000016     call lsp#log_verbose('<---', a:id, a:server_name, a:data)
    3              0.000006     let l:response = a:data['response']
    3              0.000007     let l:server = s:servers[a:server_name]
    3              0.000006     let l:server_info = l:server['server_info']
                            
    3              0.000010     let l:stream_data = { 'server': a:server_name, 'response': l:response }
    3              0.000006     if has_key(a:data, 'request')
    1              0.000003         let l:stream_data['request'] = a:data['request']
    3              0.000002     endif
    3   0.003924   0.000012     call lsp#stream(1, l:stream_data) " notify stream before callbacks
                            
    3   0.000047   0.000018     if !lsp#client#is_server_instantiated_notification(a:data)
    1              0.000002         let l:request = a:data['request']
    1              0.000002         let l:method = l:request['method']
    1              0.000002         if l:method ==# 'initialize'
                                        call s:handle_initialize(a:server_name, a:data)
    1              0.000000         endif
    3              0.000003     endif
                            
    3              0.000006     for l:callback_info in s:notification_callbacks
                                    call l:callback_info.callback(a:server_name, a:data)
    3              0.000001     endfor

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:160
Called 15 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   15              0.000044   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
   15              0.000008   endif
   15              0.000015   return s:has_lawrencium

FUNCTION  <SNR>202_on_stdout()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:33
Called 3 times
Total time:   0.005511
 Self time:   0.000491

count  total (s)   self (s)
    3              0.000015     let l:ctx = get(s:clients, a:id, {})
                            
    3              0.000006     if empty(l:ctx)
                                    return
    3              0.000001     endif
                            
    3              0.000007     let l:ctx['buffer'] .= a:data
                            
    6              0.000004     while 1
    6              0.000010         if l:ctx['content-length'] < 0
                                        " wait for all headers to arrive
    5              0.000018             let l:header_end_index = stridx(l:ctx['buffer'], "\r\n\r\n")
    5              0.000007             if l:header_end_index < 0
                                            " no headers found
    2              0.000002                 return
    3              0.000001             endif
    3              0.000009             let l:headers = l:ctx['buffer'][:l:header_end_index - 1]
    3   0.000083   0.000021             let l:ctx['content-length'] = s:get_content_length(l:headers)
    3              0.000005             if l:ctx['content-length'] < 0
                                            " invalid content-length
                                            call lsp#log('on_stdout', a:id, 'invalid content-length')
                                            call s:lsp_stop(a:id)
                                            return
    3              0.000000             endif
    3              0.000011             let l:ctx['buffer'] = l:ctx['buffer'][l:header_end_index + 4:] " 4 = len(\r\n\r\n)
    4              0.000001         endif
                            
    4              0.000012         if len(l:ctx['buffer']) < l:ctx['content-length']
                                        " incomplete message, wait for next buffer to arrive
    1              0.000000             return
    3              0.000001         endif
                            
                                    " we have full message
    3              0.000009         let l:response_str = l:ctx['buffer'][:l:ctx['content-length'] - 1]
    3              0.000004         let l:ctx['content-length'] = -1
                            
    3              0.000003         try
    3              0.000019             let l:response = json_decode(l:response_str)
                                    catch
                                        call lsp#log('s:on_stdout json_decode failed', v:exception)
    3              0.000003         endtry
                            
    3              0.000010         let l:ctx['buffer'] = l:ctx['buffer'][len(l:response_str):]
                            
    3              0.000007         if exists('l:response')
                                        " call appropriate callbacks
    3              0.000009             let l:on_notification_data = { 'response': l:response }
    3              0.000010             if has_key(l:response, 'method') && has_key(l:response, 'id')
                                            " it is a request from a server
                                            let l:request = l:response
                                            if has_key(l:ctx['opts'], 'on_request')
                                                call l:ctx['opts']['on_request'](a:id, l:request)
                                            endif
    3              0.000006             elseif has_key(l:response, 'id')
                                            " it is a request->response
    1              0.000005                 if !(type(l:response['id']) == type(0) || type(l:response['id']) == type(''))
                                                " response['id'] can be number | string | null based on the spec
                                                call lsp#log('invalid response id. ignoring message', l:response)
                                                continue
    1              0.000001                 endif
    1              0.000002                 if has_key(l:ctx['requests'], l:response['id'])
    1              0.000004                     let l:on_notification_data['request'] = l:ctx['requests'][l:response['id']]
    1              0.000001                 endif
    1              0.000002                 if has_key(l:ctx['opts'], 'on_notification')
                                                " call client's on_notification first
    1              0.000001                     try
    1   0.000942   0.000007                         call l:ctx['opts']['on_notification'](a:id, l:on_notification_data, 'on_notification')
                                                catch
                                                    call lsp#log('s:on_stdout client option on_notification() error', v:exception, v:throwpoint)
    1              0.000000                     endtry
    1              0.000000                 endif
    1              0.000003                 if has_key(l:ctx['on_notifications'], l:response['id'])
                                                " call lsp#client#send({ 'on_notification }) second
    1              0.000000                     try
    1   0.000883   0.000010                         call l:ctx['on_notifications'][l:response['id']](a:id, l:on_notification_data, 'on_notification')
                                                catch
                                                    call lsp#log('s:on_stdout client request on_notification() error', v:exception, v:throwpoint)
    1              0.000001                     endtry
    1              0.000003                     unlet l:ctx['on_notifications'][l:response['id']]
    1              0.000000                 endif
    1              0.000003                 if has_key(l:ctx['requests'], l:response['id'])
    1              0.000002                     unlet l:ctx['requests'][l:response['id']]
                                            else
                                                call lsp#log('cannot find the request corresponding to response: ', l:response)
    1              0.000000                 endif
    2              0.000002             else
                                            " it is a notification
    2              0.000006                 if has_key(l:ctx['opts'], 'on_notification')
    2              0.000000                     try
    2   0.003166   0.000016                         call l:ctx['opts']['on_notification'](a:id, l:on_notification_data, 'on_notification')
                                                catch
                                                    call lsp#log('s:on_stdout on_notification() error', v:exception, v:throwpoint)
    2              0.000001                     endtry
    2              0.000002                 endif
    3              0.000000             endif
    3              0.000002         endif
                            
    3              0.000006         if empty(l:response_str)
                                        " buffer is empty, wait for next message to arrive
                                        return
    3              0.000000         endif
    3              0.000003     endwhile

FUNCTION  <SNR>181_set_highlights()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/highlights.vim:114
Called 1 time
Total time:   0.000208
 Self time:   0.000085

count  total (s)   self (s)
                                " TODO: optimize by looking at params
    1              0.000002     if !g:lsp_diagnostics_highlights_insert_mode_enabled
                                    if mode()[0] ==# 'i' | return | endif
    1              0.000000     endif
                            
    3              0.000005     for l:bufnr in range(1, bufnr('$'))
    2   0.000023   0.000016         if lsp#internal#diagnostics#state#_is_enabled_for_buffer(l:bufnr) && bufexists(l:bufnr) && bufloaded(l:bufnr)
    2   0.000053   0.000010             let l:uri = lsp#utils#get_buffer_uri(l:bufnr)
    3   0.000035   0.000021             for [l:server, l:diagnostics_response] in items(lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri))
    1   0.000066   0.000007                 call s:place_highlights(l:server, l:diagnostics_response, l:bufnr)
    3              0.000002             endfor
    2              0.000001         endif
    3              0.000000     endfor

FUNCTION  <SNR>142_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 6 times
Total time:   0.000558
 Self time:   0.000558

count  total (s)   self (s)
                                " a:list needs to have 5 items!
    6              0.000008     let res = ''
    6              0.000008     let i = -1
   36              0.000035     while i < 4
   30              0.000035       let i += 1
   30              0.000063       let item = get(a:list, i, '')
   30              0.000030       if item is ''
   13              0.000009         continue
   17              0.000007       endif
   17              0.000042       if i == 0
    6              0.000014         let res .= ' guifg='.item
   11              0.000011       elseif i == 1
    2              0.000004         let res .= ' guibg='.item
    9              0.000009       elseif i == 2
    6              0.000012         let res .= ' ctermfg='.item
    3              0.000003       elseif i == 3
    2              0.000004         let res .= ' ctermbg='.item
    1              0.000001       elseif i == 4
    1              0.000004         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
   17              0.000008       endif
   23              0.000011     endwhile
    6              0.000006     return res

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 15 times
Total time:   0.000539
 Self time:   0.000539

count  total (s)   self (s)
   15              0.000089   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   15              0.000065     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   15              0.000053     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   15              0.000052     let default = get(g:, 'airline#extensions#keymap#default', '')
   15              0.000022     if (label !=# '')
   15              0.000028       let label .= ' '
   15              0.000010     endif
   15              0.000023     let keymap = &keymap
   15              0.000035     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   15              0.000010     endif
   15              0.000096     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  lsp#internal#diagnostics#state#_is_enabled_for_buffer()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:150
Called 50 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
   50              0.000166     return getbufvar(a:bufnr, 'lsp_diagnostics_enabled', 1) == 1

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:88
Called 15 times
Total time:   0.002349
 Self time:   0.001073

count  total (s)   self (s)
   15              0.000040   if !get(w:, 'airline_active', 0)
                                return ''
   15              0.000007   endif
                              " Cache values, so that it isn't called too often
   15   0.000392   0.000255   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   15              0.000005   endif
   15   0.001029   0.000117   let hunks = airline#extensions#hunks#get_raw_hunks()
   15              0.000019   let string = ''
   15   0.000148   0.000096   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   15              0.000027   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
   15              0.000010   endif
   15   0.000154   0.000123   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   15              0.000009   endif
                            
   15              0.000025   let b:airline_hunks = string
   15              0.000027   let b:airline_changenr = b:changedtick
   15   0.000210   0.000066   let s:airline_winwidth = airline#util#winwidth()
   15              0.000015   return string

FUNCTION  293()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/matchparen.vim:203
Called 1 time
Total time:   0.000073
 Self time:   0.000015

count  total (s)   self (s)
                              ""
                              " fade feature: remove highlights after a certain time
                              " {level}
                              "   =  0: prepare for possible loss of cursor support
                              "   =  1: new highlights are coming (cancel prior fade)
                              "   =  2: end of new highlights
                              " {pos}     [lnum, column] of current match
                              " {token}   in/out saves state between calls
                              "
                              " returns 1 if highlighting should be canceled
                            
    1              0.000002   if !g:matchup_matchparen_deferred || !exists('w:matchup_fade_timer')
    1              0.000002     if a:level <= 0
    1   0.000062   0.000004       call s:matchparen.clear()
    1              0.000000     endif
    1              0.000001     return 0
                              endif
                            
                              " jumping between windows
                              if a:level == 0 && win_getid() != get(s:, 'save_win')
                                call timer_pause(w:matchup_fade_timer, 1)
                                if exists('w:matchup_fade_pos')
                                  unlet w:matchup_fade_pos
                                endif
                                call s:matchparen.clear()
                                let s:save_win = win_getid()
                              endif
                            
                              " highlighting might be stale
                              if a:level == 0
                                if exists('w:matchup_fade_pos')
                                  let a:token.save_pos = w:matchup_fade_pos
                                  unlet w:matchup_fade_pos
                                endif
                                if !w:matchup_need_clear
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                                return 0
                              endif
                            
                              " prepare for new highlighting
                              if a:level == 1
                                " if token has no save_pos, cursor was previously off of a match
                                if !has_key(a:token, 'save_pos') || a:pos != a:token.save_pos
                                  " clear immediately
                                  call timer_pause(w:matchup_fade_timer, 1)
                                  call s:matchparen.clear()
                                  return 0
                                endif
                                let w:matchup_fade_pos = a:token.save_pos
                                return 1
                              endif
                            
                              " new highlighting is active
                              if a:level == 2 && a:pos != get(w:, 'matchup_fade_pos', [])
                                " init fade request
                                let w:matchup_fade_pos = a:pos
                                let w:matchup_fade_start = reltime()
                                call timer_pause(w:matchup_fade_timer, 0)
                              endif
                            
                              return 0

FUNCTION  295()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/matchparen.vim:342
Called 2 times
Total time:   0.001262
 Self time:   0.000291

count  total (s)   self (s)
    2              0.000008   if !g:matchup_matchparen_enabled | return | endif
                            
    2              0.000018   if has('vim_starting') | return | endif
                            
    2              0.000008   if !g:matchup_matchparen_pumvisible && pumvisible() | return | endif
                            
                              " try to avoid interfering with some auto-complete plugins
    2              0.000013   if has('*state') && state('a') !=# '' | return | endif
                            
    2              0.000015   if !get(b:, 'matchup_matchparen_enabled', 1) && get(b:, 'matchup_matchparen_fallback', 1) && s:pi_paren_sid()
                                return call(s:pi_paren_fcn, [])
    2              0.000002   endif
                            
    2              0.000008   if !get(b:, 'matchup_matchparen_enabled', 1) | return | endif
                            
    2              0.000012   let l:force_update    = a:0 >= 1 ? a:1 : 0
    2              0.000007   let l:changing_insert = a:0 >= 2 ? a:2 : 0
    2              0.000015   let l:real_mode = l:changing_insert ? v:insertmode : mode()
                            
    2   0.000251   0.000045   if !l:force_update && exists('w:last_changedtick') && exists('w:last_cursor') && matchup#pos#equal(w:last_cursor, matchup#pos#get_cursor()) && w:last_changedtick == b:changedtick
    1              0.000001     return
    1              0.000001   endif
    1              0.000003   let w:last_changedtick = b:changedtick
    1   0.000009   0.000005   let w:last_cursor = matchup#pos#get_cursor()
                            
    1   0.000015   0.000009   call matchup#perf#tic('matchparen.highlight')
                            
                              " request eventual clearing of stale matches
    1              0.000002   let l:token = {}
    1   0.000083   0.000010   call self.fade(0, [], l:token)
                            
    1              0.000003   let l:modes = g:matchup_matchparen_nomode
    1              0.000002   if get(g:, 'matchup_matchparen_novisual', 0)  " deprecated option name
                                let l:modes .= "vV\<c-v>"
    1              0.000000   endif
    1              0.000004   if stridx(l:modes, l:real_mode) >= 0
                                return
    1              0.000001   endif
                            
                              " prevent problems in visual block mode at the end of a line
    1   0.000011   0.000009   if get(matchup#pos#get_cursor(), 4, 0) == 2147483647 && "v\<c-v>" =~? mode()
                                return
    1              0.000000   endif
                            
                              " don't get matches when inside a closed fold
    1              0.000003   if foldclosed(line('.')) > -1
                                return
    1              0.000000   endif
                            
                              " give up when cursor is far into a very long line
    1              0.000005   if &synmaxcol && col('.') > &synmaxcol
                                return
    1              0.000000   endif
                            
                              " in insert mode, cursor is treated as being one behind
    1              0.000002   let l:insertmode = l:real_mode ==# 'i'
                            
                              " start the timeout period
    1              0.000006   let l:timeout = l:insertmode ? get(b:, 'matchup_matchparen_insert_timeout',           g:matchup_matchparen_insert_timeout) : get(b:, 'matchup_matchparen_timeout',           g:matchup_matchparen_timeout)
    1   0.000021   0.000008   call matchup#perf#timeout_start(l:timeout)
                            
    1   0.000656   0.000012   let l:current = matchup#delim#get_current('all', 'both_all', { 'insertmode': l:insertmode,   'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
    1   0.000031   0.000008   call matchup#perf#toc('matchparen.highlight', 'get_current')
                            
    1              0.000003   if get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
                                let l:hsa = get(b:, 'matchup_matchparen_hi_surround_always', g:matchup_matchparen_hi_surround_always)
                                if l:hsa > 0 && empty(l:current) || l:hsa > 1
                                  call s:highlight_surrounding(l:insertmode, !empty(l:current))
                                endif
    1              0.000001   endif
                            
    1              0.000002   if empty(l:current)
    1              0.000001     return
                              endif
                            
                              let l:corrlist = matchup#delim#get_matching(l:current, { 'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
                              call matchup#perf#toc('matchparen.highlight', 'get_matching')
                              if empty(l:corrlist) | return | endif
                            
                              if g:matchup_transmute_enabled
                                if !exists('w:matchup_matchparen_context')
                                  let w:matchup_matchparen_context = { 'normal': {   'current':   {},   'corrlist':  [],  }, 'prior': {}, 'counter': 0,}
                                endif
                            
                                let w:matchup_matchparen_context.counter += 1
                            
                                if !l:insertmode
                                  let w:matchup_matchparen_context.prior = copy(w:matchup_matchparen_context.normal)
                            
                                  let w:matchup_matchparen_context.normal.current = l:current
                                  let w:matchup_matchparen_context.normal.corrlist = l:corrlist
                                endif
                            
                                " if transmuted, highlight again (will reset timeout)
                                if matchup#transmute#tick(l:insertmode)
                                  " no force_update here because it would screw up prior
                                  return s:matchparen.highlight(0, l:changing_insert)
                                endif
                              endif
                            
                              if !has_key(l:current, 'match_index') || len(l:corrlist) <= (l:current.side ==# 'mid' ? 2 : 1) && !g:matchup_matchparen_singleton
                                " TODO this doesn't catch every case, needs refactor
                                " TODO singleton doesn't work right for mids
                                return
                              endif
                            
                              " prepare for (possibly) new highlights
                              let l:pos = [l:current.lnum, l:current.cnum]
                              if self.fade(1, l:pos, l:token)
                                return
                              endif
                            
                              " store flag meaning highlighting is active
                              let w:matchup_need_clear = 1
                            
                              " disable off-screen when scrolling with j/k
                              let l:scrolling = get(g:matchup_matchparen_offscreen, 'scrolloff', 0) && winheight(0) > 2*&scrolloff && (line('.') == line('w$')-&scrolloff     && line('$') != line('w$')     || line('.') == line('w0')+&scrolloff)
                            
                              " show off-screen matches
                              let l:method = get(g:matchup_matchparen_offscreen, 'method', '')
                              if !empty(l:method) && l:method !=# 'none' && !l:current.skip && !l:scrolling && winheight(0) > 0
                                call s:do_offscreen(l:current, l:method)
                              endif
                            
                              " add highlighting matches
                              call s:add_matches(l:corrlist, l:current)
                            
                              " highlight the background between parentheses
                              if g:matchup_matchparen_hi_background >= 1
                                call s:highlight_background(l:corrlist)
                              endif
                            
                              " new highlights done, request fade away
                              call self.fade(2, l:pos, l:token)
                            
                              call matchup#perf#toc('matchparen.highlight', 'end')

FUNCTION  lsp#internal#diagnostics#under_cursor#get_diagnostic()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/under_cursor.vim:6
Called 1 time
Total time:   0.000136
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000004     let l:options = get(a:000, 0, {})
    1              0.000003     let l:server = get(l:options, 'server', '')
    1              0.000003     let l:bufnr = bufnr('%')
                            
    1   0.000010   0.000006     if !lsp#internal#diagnostics#state#_is_enabled_for_buffer(l:bufnr)
                                    return {}
    1              0.000000     endif
                            
    1   0.000040   0.000005     let l:uri = lsp#utils#get_buffer_uri(l:bufnr)
                            
    1   0.000018   0.000008     let l:diagnostics_by_server = lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri)
    1              0.000002     let l:diagnostics = []
    1              0.000002     if empty(l:server)
    2              0.000005         for l:item in values(l:diagnostics_by_server)
    1   0.000010   0.000006             let l:diagnostics += lsp#utils#iteratable(l:item['params']['diagnostics'])
    2              0.000002         endfor
                                else
                                    if has_key(l:diagnostics_by_server, l:server)
                                        let l:diagnostics = lsp#utils#iteratable(l:diagnostics_by_server[l:server]['params']['diagnostics'])
                                    endif
    1              0.000000     endif
                            
    1              0.000002     let l:line = line('.')
    1              0.000003     let l:col = col('.')
                            
    1              0.000002     let l:closest_diagnostic = {}
    1              0.000001     let l:closest_distance = -1
                            
    1              0.000001     for l:diagnostic in l:diagnostics
                                    let [l:start_line, l:start_col] = lsp#utils#position#lsp_to_vim('%', l:diagnostic['range']['start'])
                            
                                    if l:line == l:start_line
                                        let l:distance = abs(l:start_col - l:col)
                                        if l:closest_distance < 0 || l:distance < l:closest_distance
                                            let l:closest_diagnostic = l:diagnostic
                                            let l:closest_distance = l:distance
                                        endif
                                    endif
    1              0.000001     endfor
                            
    1              0.000001     return l:closest_diagnostic

FUNCTION  <SNR>193_clear_signs()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/signs.vim:104
Called 1 time
Total time:   0.000016
 Self time:   0.000009

count  total (s)   self (s)
                                " TODO: optimize by looking at params
    1   0.000014   0.000007     call s:clear_all_signs()

FUNCTION  lsp#callbag#fromEvent()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:465
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000006     let l:data = { 'events': a:events }
    2              0.000003     if a:0 > 0
                                    let l:data['augroup'] = a:1
    2              0.000001     else
    2              0.000009         let l:data['augroup'] = '__callbag_fromEvent_prefix_' . s:event_prefix_index . '__'
    2              0.000004         let s:event_prefix_index = s:event_prefix_index + 1
    2              0.000001     endif
    2              0.000008     return function('s:fromEventFactory', [l:data])

FUNCTION  matchup#perf#tic()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/perf.vim:15
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000012   let s:time_start[a:context] = reltime()

FUNCTION  <SNR>174_mapF()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:414
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000005     let a:data['source'] = a:source
    2              0.000009     return function('s:mapFSource', [a:data])

FUNCTION  <SNR>202_is_server_instantiated_notification()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:280
Called 3 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    3              0.000007     return !has_key(a:notification, 'request')

FUNCTION  matchup#delim#get_current()
    Defined: ~/.vim/plugged/vim-matchup/autoload/matchup/delim.vim:28
Called 1 time
Total time:   0.000644
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000643   0.000020   return s:get_delim_multi(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  <SNR>174_fromEventFactory()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:478
Called 2 times
Total time:   0.001236
 Self time:   0.001189

count  total (s)   self (s)
    2              0.000005     if a:start != 0 | return | endif
    2              0.000005     let a:data['sink']  = a:sink
    2              0.000004     let a:data['disposed'] = 0
    2              0.000013     let a:data['handler'] = function('s:fromEventHandlerCallback', [a:data])
    2              0.000005     let a:data['handler_index'] = s:event_handler_index
    2              0.000005     let s:event_handler_index = s:event_handler_index + 1
    2   0.000068   0.000021     call a:sink(0, function('s:fromEventSinkHandler', [a:data]))
                            
    2              0.000007     if a:data['disposed'] | return | endif
    2              0.000010     let s:event_handlers_data[a:data['handler_index']] = a:data
                            
    2              0.000029     execute 'augroup ' . a:data['augroup']
    2              0.000980     execute 'autocmd!'
    2              0.000017     let l:events = type(a:data['events']) == type('') ? [a:data['events']] : a:data['events']
    4              0.000007     for l:event in l:events
    2              0.000009         let l:exec =  'call s:notify_event_handler(' . a:data['handler_index'] . ')'
    2              0.000005         if type(l:event) == type('')
    2              0.000026             execute 'au ' . l:event . ' * ' . l:exec
                                    else
                                        execute 'au ' . join(l:event, ' ') .' ' .  l:exec
    2              0.000001         endif
    4              0.000004     endfor
    2              0.000004     execute 'augroup end'

FUNCTION  lsp#utils#step#start()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/step.vim:17
Called 2 times
Total time:   0.002658
 Self time:   0.000004

count  total (s)   self (s)
    2   0.001357   0.000068     call s:next(a:steps, 0, [])

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   19   0.108705   0.002224  airline#check_mode()
    9   0.102401   0.015716  airline#highlighter#highlight()
  237   0.066472   0.020853  airline#highlighter#exec()
  363   0.055176   0.022071  airline#highlighter#get_highlight()
   63   0.038146   0.002388  <SNR>142_exec_separator()
 1452   0.031125             <SNR>142_get_syn()
  126   0.019218   0.000957  airline#themes#get_highlight()
   41   0.010863   0.000765  <SNR>174_filterSourceCallback()
   11   0.007798   0.000080  <SNR>174_mapFSourceCallback()
   15   0.007295   0.000481  airline#extensions#branch#get_head()
    8   0.007246   0.000017  <SNR>216_next()
   15   0.006383   0.000356  airline#extensions#branch#head()
   30   0.006289   0.001246  airline#extensions#lsp#get()
    5   0.006228   0.000114  <SNR>174_debounceTimeTimerCallback()
    3   0.005538   0.000027  <SNR>217_out_cb()
    3   0.005511   0.000491  <SNR>202_on_stdout()
  237   0.005276             <SNR>142_CheckDefined()
    3   0.004946   0.000114  <SNR>174_distinctUntilChangedSourceCallback()
    4   0.004929   0.000027  lsp#stream()
    4   0.004890   0.001172  <SNR>174_makeSubjectFactory()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1452              0.031125  <SNR>142_get_syn()
  363   0.055176   0.022071  airline#highlighter#get_highlight()
  237   0.066472   0.020853  airline#highlighter#exec()
    9   0.102401   0.015716  airline#highlighter#highlight()
  237              0.005276  <SNR>142_CheckDefined()
  231              0.002870  <SNR>142_hl_group_exists()
   63   0.038146   0.002388  <SNR>142_exec_separator()
   19   0.108705   0.002224  airline#check_mode()
  363              0.001980  <SNR>142_get_array()
  201              0.001726  <SNR>142_group_not_done()
   15   0.001963   0.001564  airline#extensions#whitespace#check()
   30   0.002723   0.001501  lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer()
  134              0.001321  airline#util#winwidth()
   30   0.006289   0.001246  airline#extensions#lsp#get()
    2   0.001236   0.001189  <SNR>174_fromEventFactory()
    4   0.004890   0.001172  <SNR>174_makeSubjectFactory()
   54   0.001377   0.001084  lsp#utils#get_buffer_uri()
   15   0.002349   0.001073  airline#extensions#hunks#get_hunks()
   15   0.001190   0.001006  <SNR>145_update_untracked()
   30              0.000983  FugitiveGitDir()

